---
title: 收发消息
description: 收发消息
tags:
  - rocketmq-hm
categories:
  - 学习
date: 2023-04-07 14:31:59
updated: 2023-04-07 14:31:59
---

> 转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!

# 前提

## 依赖包

```xml
		<dependency>
            <groupId>org.apache.rocketmq</groupId>
            <artifactId>rocketmq-client</artifactId>
            <version>4.4.0</version>
        </dependency>
```

## 消息生产者步骤

创建生产者，生产者组名-->指定nameserver地址-->启动producer-->

创建消息对象(Topic、Tag、消息体)

发送消息、关闭生产者producer

## 消息消费者步骤

创建消费者，制定消费者组名-->指定nameserver地址

订阅Topic和Tag，设置回调函数处理消息

启动消费者consumer

# 消息发送

## 同步消息

发送消息后客户端会进行阻塞，直到得到结果后，客户端才会继续执行

```java
    public static void main(String[] args) throws MQClientException, MQBrokerException, RemotingException, InterruptedException {
        //创建Producer，并指定生产者组
        DefaultMQProducer producer = new DefaultMQProducer("group1");
        producer.setNamesrvAddr("192.168.1.135:9876;192.168.1.138:9876");
        producer.start();
        for (int i = 0; i < 10; i++) {
            Message msg = new Message();
            msg.setTopic("base");
            msg.setTags("Tag1");
            msg.setBody(("hello world" + i).getBytes());
            //发送消息
            SendResult result = producer.send(msg);
            //发送状态
            SendStatus sendStatus = result.getSendStatus();
            //消息id
            String msgId = result.getMsgId();
            //消息接收队列id
            MessageQueue messageQueue = result.getMessageQueue();
            int queueId = messageQueue.getQueueId();
            log.info(result.toString());
            log.info(messageQueue.toString());
            log.info("status:" + sendStatus +
                    "msgId:" + msgId + "queueId" + queueId);
            TimeUnit.SECONDS.sleep(1);
        }
        log.info("发送结束===================");
        producer.shutdown();
    }
```



## 异步消息

发送消息后不会导致阻塞，当broker返回结果时，会调用回调函数进行处理

```java
    public static void main(String[] args) throws MQClientException, MQBrokerException, RemotingException, InterruptedException {
        //创建Producer，并指定生产者组
        DefaultMQProducer producer = new DefaultMQProducer("group1");
        producer.setNamesrvAddr("192.168.1.135:9876;192.168.1.138:9876");
        producer.start();
        for (int i = 0; i < 10; i++) {
            Message msg = new Message();
            msg.setTopic("base");
            msg.setTags("Tag1");
            msg.setBody(("hello world" + i).getBytes());
            //发送消息
            producer.send(msg, new SendCallback() {
                @Override
                public void onSuccess(SendResult result) {
                    //发送状态
                    SendStatus sendStatus = result.getSendStatus();
                    //消息id
                    String msgId = result.getMsgId();
                    //消息接收队列id
                    MessageQueue messageQueue = result.getMessageQueue();
                    int queueId = messageQueue.getQueueId();
                    log.info(result.toString());
                    log.info(messageQueue.toString());
                    log.info("status:" + sendStatus +
                            "msgId:" + msgId + "queueId" + queueId);
                }

                @Override
                public void onException(Throwable throwable) {
                    log.error("发送异常" + throwable);
                }
            });

            //TimeUnit.SECONDS.sleep(1);
        }
        log.info("发送结束===================");
        TimeUnit.SECONDS.sleep(3);
    }
```

## 单向消息

**不关心发送结果**

```java
    public static void main(String[] args) throws MQClientException, MQBrokerException, RemotingException, InterruptedException {
        //创建Producer，并指定生产者组
        DefaultMQProducer producer = new DefaultMQProducer("group1");
        producer.setNamesrvAddr("192.168.1.135:9876;192.168.1.138:9876");
        producer.start();
        for (int i = 0; i < 10; i++) {
            Message msg = new Message();
            msg.setTopic("base");
            msg.setTags("Tag3");
            msg.setBody(("hello world danxiang" + i).getBytes());
            //发送消息
            producer.sendOneway(msg);

            //TimeUnit.SECONDS.sleep(1);
        }
        log.info("发送结束===================");
        TimeUnit.SECONDS.sleep(3);
    }
```

# 消费消息

```java
   public static void main(String[] args) throws MQClientException {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("group1");
        consumer.setNamesrvAddr("192.168.1.135:9876;192.168.1.138:9876");
        consumer.subscribe("base", "Tag3");
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
                for (MessageExt messageExt : list) {
                    log.info(messageExt.toString());
                    String s = new String(messageExt.getBody());
                    log.info(s);
                }
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        consumer.start();
    }
```

## 消费模式

![image-20230407171826975](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230407171826975.png)

## 注意事项

1. 如果一个消息在广播消费模式下被消费过，之后再启动一个消费者，那么它可以在集群消费模式下再被消费一次。或者：  
   如果一个消息在集群消费模式下被消费过，之后再启动一个消费者，那么它可以在广播消费模式下再被消费一次
2. 如果一个消息在广播消费模式下被消费过，之后再启动一个消费者，那么它不能在广播模式下再被消费。或者  
   如果一个消息在集群消费模式下被消费过，之后再启动一个消费者，那么它不能在集群模式下再被消费。

## 顺序消息

