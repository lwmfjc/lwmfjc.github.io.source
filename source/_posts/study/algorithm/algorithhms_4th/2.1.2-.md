---
title: 算法红皮书 2.1.2-
description: '选择排序'
categories:
  - 学习
tags:
  - 算法红皮书(第四版)
date: 2022-04-23 15:54:21
updated: 2022-04-26 11:26:21
---

# 排序

## 初级排序算法

### 选择排序

- 命题A。对于长度为N 的数组，选择排序需要大约N2/2 次比较和N 次交换。

- 代码

  ```java
  public class Selection
  {
  	public static void sort(Comparable[] a)
  	{
  		// 将a[]按升序排列
  		int N = a.length;
  		// 数组长度
  		for (int i = 0; i < N; i++)
  		{
  			// 将a[i]和a[i+1..N]中最小的元素交换
  			int min = i;
  			// 最小元素的索引
  			for (int j = i+1; j < N; j++)
  			if (less(a[j], a[min])) min = j;
  			exch(a, i, min);
  		}
  	}
  	// less()、exch()、isSorted()和main()方法见“排序算法类模板”
  }
  ```

- 特点

  - 运行时间与输入无关，即输入数据的初始状态（比如是否已排序好等等）不影响排序时间
  - 数据移动是最少的（只使用了N次交换，交换次数和数组的大小是线性关系

### 插入排序

- 命题B。对于随机排列的长度为N 且主键不重复的数组，平均情况下插入排序需要～ N2/4 次比较以及～ N2/4 次交换。最坏情况下需要～ N2/2 次比较和～ N2/2 次交换，最好情况下需要N-1次比较和0 次交换。

- 代码

  ```java
  public static void sort(Comparable[] a) {
          int N = a.length;
          //将下表为 n-1的数，依次和n-2,n-3一直到0比较，
          //所以第二层for只走到1，因为0前面没有值
          //如果比前面的值小，就进行交换
          for (int i = 1; i < N; i++) {
              for (int j = i; j > 0 && less(a[j], a[j - 1]); j--) {
                  exch(a, j, j - 1);
              }
          }
      }
  ```

- 当倒置的数量很小时，插入排序比本章中的其他任何算法都快

- > 命题C。插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。

- > 性质D。对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数

### 希尔排序

- 希尔排序的思想是使数组中任意间隔为h的元素都是有序的，这样的数组称为h有序数组，一个h有序数组就是h个互相独立的有序数组编制在一起组成的数组

- 算法2.3 的实现使用了序列1/2（3k-1），从N/3 开始递减至1。我们把这个序列称为递增序列

- 详述

- 实现希尔排序的一种方法是对于每个h，用插入排序将h 个子数组独立地排序。但因为子数组是相互独立的，一个更简单的方法是在h- 子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插入排序的代码中将移动元素的距离由1 改为h 即可。这样，希尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。

- 代码

  ```java
  public class Shell
  {
  	public static void sort(Comparable[] a)
  	{
  		// 将a[]按升序排列
  		int N = a.length;
  		int h = 1;
  		while (h < N/3) h = 3*h + 1;
  		// 1, 4, 13, 40, 121, 364, 1093, ...
  		while (h >= 1)
  		{
  			// 将数组变为h有序
  			for (int i = h; i < N; i++)
  			{
  				// 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中
  				for (int j = i; j >= h && less(a[j], a[j-h]); j -= h)
  				exch(a, j, j-h);
  			}
  			h = h/3;
  		}
  	}
  	// less()、exch()、isSorted()和main()方法见“排序算法类模板”
  }
  ```
  
- 通过提升速度来解决其他方式无法解决的问题是研究算法的设计和性能的主要原因之一

## 归并排序

归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需时间和NlogN成正比，主要缺点是他所需的额外空间和N成正比

- 归并排序示意图
  ![image-20220426093850545](2.1.2-/image-20220426093850545.png)

- 原地归并的抽象方法

  ```java
  
      /**
       * 这里有一个前提，就是a[i..mid]是有序的，
       * a[mid..hi]是有序的
       *
       * @param a
       * @param lo
       * @param mid
       * @param hi
       */
      public static void merge(Comparable[] a,
                               int lo, int mid, int hi) {
          int i = lo, j = mid + 1;
          //先在辅助数组赋上需要的值
          for (int k = lo; k <= hi; k++) {
              aux[k] = a[k];
          }
          for (int k = lo; k <= hi; k++) {
              if (i > mid) {
                  //说明i(左边）比较完了，直接拿右边的值放进去
                  a[k] = aux[j++];
              } else if (j > hi) {
                  //说明j(右边)比较完了，直接拿左边的值放进去
                  a[k] = aux[i++];
              } else if (less(aux[j], aux[i])) {
                  //左右都还有值的情况下，取出最小的值放进去
                  a[k] = aux[j++];
              } else {
                  a[k] = aux[i++];
              }
          }
      }
  ```

- 递归进行归并排序

  ```java
  private static void sort(Comparable[] a, int lo, int hi) {
          if (hi <= lo) {
              return;
          }
          int mid = lo + (hi - lo) / 2;
          //保证左边有序
          sort(a, lo, mid);
          //保证右边有序
          sort(a, mid + 1, hi);
          //归并数组有序的两部分
          merge(a, lo, mid, hi);
      }
  ```

- 辅助数组的一次性初始化

  ```java
  private static Comparable[] aux;
  
      public static void sort(Comparable[] a) {
          aux = new Comparable[a.length];//辅助数组，一次性分配空间
          sort(a, 0, a.length - 1);
      }
  ```

- 自顶向下的归并排序的调用轨迹
  ![image-20220426111242973](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220426111242973.png)

- 
