---
title: 06B+树索引
description: 06B+树索引
tags:
  - MySQL是怎样运行的
categories:
  - 学习
date: 2023-04-22 15:04:46
updated: 2023-04-22 15:04:46
---

> 学习《MySQL是怎样运行的》，感谢作者！

# 概述

数据页由**7个**组成部分，各个数据页可以组成一个**双向链表**，每个数据页中的记录会按照**主键值从小到大的顺序**组成一个**单向链表**。每个数据页都会为**它里面的记录**生成一个**页目录**，在通过主键查找某条记录的时候可以在**页目录**中使用二分法快速定位到**对应的槽**，然后再**遍历该槽**对应**分组中的记录**即可快速找到**指定**的记录。**页和记录**的关系    

> 页a，页b 可以**不在物理结构上相连**，只要通过**双向链表相关联**即可

![image-20230422205909858](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230422205909858.png)

# 没有索引时进行查找

假设我们要搜索**某个列**等于**某个常数**的情况：  
```SELECT [查询列表] FROM 表名 WHERE 列名 = xxx```

## 在一个页中查找

假设记录极少，所有记录可以**存放到一个页中**  

- 以**主键**位搜索条件：页目录中使用**二分法**快速定位到对应的**槽**，然后在**遍历槽对应分组中的记录**，即可快速找到指定记录
- 其他列作为搜索条件：对于**非主键**，数据页没有为**非主键列**建立所谓的**页目录**，所以**无法通过二分法**快速定位相应的槽。只能**从Infimum依次遍历**单向链表中的每条记录，然后对比，效率极低

## 在很多页中查找

两个步骤：  

- **定位到记录所在的页**
- 从**所在页内**查找相应的记录

**没有索引**情况下，不能快速定位到所在页，只能从**第一页**沿着**双向链表**一直往下找，而如果是主键，每一页则可以在**页目录**二分查找。  
不过由于要**遍历所有页**，所以超级**耗时**

# 索引

```shell
#例子
mysql> CREATE TABLE index_demo(
    -> c1 INT,
    -> c2 INT,
    -> c3 CHAR(1),
    -> PRIMARY KEY(c1)
    -> ) ROW_FORMAT=COMPACT;
```

> 完整的行格式

![image-20230423113811933](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423113811933.png)

简化的行格式  
![image-20230423111720338](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423111720338.png)

- record_type：**记录头信息**的一项属性，表示**记录的类型**。0：普通记录，2：Infimum记录，3：Supremum记录，1还没用过等会再说
- next_record：**记录头信息**的一项属性，表示从当前记录的**真实数据**到**下一条记录真实数据**的距离
- 各个列的值：这里只展示在index_demo表中的**3个列**，分别是c1、c2、c3
- 其他信息：包括**隐藏列**及**记录的额外信息**

改为竖着查看：  
![image-20230423114517255](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423114517255.png)

> 上面图6-4的箭头其实有一点点出入，应该是指向z真实数据第1列那个位置，如下 
> ![image-20230423114716300](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423114716300.png)

## 一个简单的索引方案

思考：在**根据某个条件**查找一些记录，为什么要**遍历所有**的**数据页**呢？因为各个**页**中的记录没有规律，不知道**搜索条件会匹配哪些页**  
思路：为**快速定位**记录所在的**数据页**而建立一个别的目录  

### 有序   

下一个数据页中**用户记录**的**主键值**必须大于上一页**用户记录**的**主键值**  
假设一页只能存放3条记录   

```shell
#插入3条记录
mysql> INSERT INTO index_demo VALUES(1,4,'u'),(3,9,'d'),(5,3,'y');
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0
```

此时页的情况  
**记录组成了单链表**  
![image-20230423120232629](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423120232629.png)

再**插入一条记录**  

```shell
mysql> INSERT INTO index_demo VALUES(4,4,'a');
Query OK, 1 row affected (0.01 sec)
```

(注意，页之间可能**不是连续**的)

![image-20230423120335929](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423120335929.png)

由于页10中**最大记录**是**5**，而页28中有一条记录是**4**，因为5>4，不符合**下一个数据页中用户记录的主键值**必须**大于上一页中用户记录的主键值**，所以在**插入主键值为4的记录时需要伴随着一次记录移动**，也就是把5的记录移动到**页28**中，再把**主键值4**的记录**插入到页10中**  
![image-20230423122233694](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423122233694.png)

这个过程表明，在对页中的记录进行**增删改**操作的过程中，我们必须通过一些诸如**记录移动**的操作来始终保证这个状态一直成立：**下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值**。这个过程也可以称为**页分裂**。

### 给所有的页建立一个目录项

前提：index_demo表中有多条记录的效果  
![image-20230423122443198](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423122443198.png)

1页有16KB，这些页在磁盘上可能并不连续，**要想从这么多页中**根据**主键值**快速定位**某些记录所在的页**，需要给他们编制一个**目录**，每个页对应一个**目录项**，每个目录项包括**两部分**：  

- 页的**用户记录**中**最小的主键值**，用**key**表示
- 页号，**page_no**表示 

![image-20230423122846720](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423122846720.png)

假设我们此时把**目录项**在**物理存储器上连续存储**，比如放到数组中，此时就可以**根据主键值**快速查找**某条记录**  

1. 先用二分法快速定位主键20的记录在**目录项3中**（因为**12<20<209**)，对应页是9

2. 根据前面说的方式在**页9中**定位具体记录    

   > 先在**页目录**中二分查找，找到对应的组后**沿链表遍历**

这个目录项的别名：**索引**

## InnoDB中的索引方案

### 上述方案的问题

- InnoDB使用页作为**管理存储空间**的基本单位，即**只能保证16KB**的**连续存储空间**，如果记录非常多，则需要的**连续存储空间**就**非常大**
- **增删改**是很频繁的，如果页28的记录全部移除，那么目录项2就没有出现的必要，即**要删除目录项2**，那么所有的**目录项**都需要**左移**/或者不移动，作为冗余**放到目录项列表**中，浪费空间

### 方案

复用之前存储用户记录的**数据页**来存储目录项，用了和**用户记录**进行区分，把这些**用来表示目录项**的记录称为**目录项记录**。如何区分一条记录是**普通用户记录**，还是**目录项记录**：使用**记录头信息**中的**record_type**属性  

- 0：普通用户记录
- 1：目录项记录
- 2：Infimum记录
- 3：Supremum记录

**将目录项放到数据页中**  
![image-20230423140229838](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423140229838.png)

**新分配了一个编号为30的页来专门存储目录项记录**  
**目录项记录**和**普通的用户记录**的不同点  

- 目录项记录的**record_type**值为1，普通用户记录**record_type**值为0

- 目录项记录只有**主键值**和**页的编号**这两个列，而普通用户记录的**列**是用户自己定义的，可能包含许多列，另外还有**InnoDB**自己添加的**隐藏列**

- **记录头信息**中有一个名为**min_rec_flag**的属性，只有目录项记录的min_rec_flag属性才可能为1，普通记录的min_rec_flag属性都是0  

  > B+ 树中**每层**非叶子节点中的**最小的目录项**记录都会添加该标记

**其他**：  
它们用的是**一样的数据页**(**页面类型**都是Ox45BF ，这个属性在File Header 中)；页的**组成结构**也是一样的〈就是我们前面介绍过的**7 个部分**)；都会为主键值生成**Page Directory**（页目录）从而在**按照主键值进行查找**时可以**使用**
**二分法**来加快查询速度。

### 举例

#### 单个 目录项记录页

![image-20230423140327842](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423140327842.png)

其中，页30中存储的**主键值**分别为**1**，**5**，**12**，**209**  
假设我们现在要查找**主键值为20的记录**：  

1. 先到**存储目录项记录的页（这里是页30）**中，（由于有**页目录**）通过二分法**快速**定位到对应的**目录项记录**，因为12<20<209，所以定位到对应的**用户记录**所在的页就是**页9**
2. 再到**存储用户记录**的**页9**中根据**二分法**（**由于有页目录）**）快速定位到**主键值为20**的用户记录

**目录项记录**中只**存储主键值**和**对应的页号**，存储空间极小，但一个页只有16KB，存放的**目录项记录**有限。如果表中数据太多（**页太多**），以至于**一个数据页**不足以存放所有的**目录项记录**

#### 多个 目录项记录的页

解决方案：**新增一个存储目录项记录的页**  


![image-20230423141605646](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423141605646.png)

此时再进行查找

- 确定存储目录项记录的页  
  现在**存储目录项记录的页**有2个，即页30和页32。又因为页30表示的目录项**记录主键值**范围是**[1，320)**，页32表示的**目录项记录主键值**范围 **> 320**。所以确定主键值为20的记录**对应的目录项记录**在页30中
- 按照**单个** **目录项记录页**的方案查找

# 多个目录项记录页

如果数据再增加，则再**生成存储更高级目录项记录**的**数据页**  
![image-20230423142254862](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423142254862.png)

无论是**存放用户记录**的数据页，还是**存放目录项记录**的数据页，都放到B+树数据结构中，我们也将这些**数据页**称为**B+树的节点**  
如图，我们真正的**用户记录**其实都存放在B+树**最底层的节点上**，这些节点也称为**叶子节点**或**页节点**，其余用来存放**目录项记录**的节点称为**非叶子节点**或者**内节点**，其中B+树最上边的那个节点也称为**根节点**
![image-20230423142809455](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423142809455.png)

这里我们规定，**最下面**那层（存放**用户记录**的那层）为0层，之后**层级**依次往上加。  
这里我们假设所有存放**用户记录**的**叶子节点**所代表的**数据页**可以存放100条**用户记录**（16KB=16 * 1024 ≈10000 字节，差不多一条记录100字节），假设所有存放**目录项记录**的**内节点**所代表的**数据页**可以存放1000条**目录项记录**（10000字节，假设**1个目录项10字节**），那么如果  

- 如果B+树有1层，那么只有一个用于存放用户记录的节点，那么能存放100条用户记录（1百）
- 如果B+树有2层，那么能存放 1000 * 100=100,000条用户记录(10万)
- 如果B+树有3层，那么能存放 1000 * 1000 * 100=100,000,000条用户记录(1亿)
- 如果B+树有4层，那么能存放 1000 * 1000 * 1000 * 100=100,000,000,000条用户记录 (1000亿)

所以**一般情况**下，我们用到的**B+树不会超过4层**。  

当我们要通过**主键值**查找**某条记录  **

- **最多只需要进行**4个页面内的查找（查找**3个存储目录项记录**的页和**1个存储用户记录**的页）  
- 每个页面内存在**PageDirectory（页目录）**，所以在页面内**也可以**通过**二分法**快速定位记录  

> PageHeader中，有一个名为**PAGE_LEVEL**的属性，代表着**这个数据页**作为**节点**在B+树中的层级

## 聚簇索引

前面介绍的B+树**本身就是一个记录**，或者说**本身就是一个索引**，有以下两个特点  

- 使用**记录主键值**的大小进行**记录**和**页**的排序  
  1. 页（包括**叶子节点**和**内节点**）内的记录，按照**主键大小**顺序排成一个单向链表，**页内的记录**被划分成**若干个组**，每个组中**主键值最大**的记录在**页内的偏移量**会被当作**槽**一次存放在**页目录中**（Supremum记录比任何用户记录都大）之后可以在**页目录**中通过**二分法**快速定位到**主键列**等于**某个值**的记录
  2. 各个**存放用户记录**的**页**也是根据**页中用户记录**的**主键大小**顺序排成一个**双向链表**
  3. 存放**目录项记录**的页分为不同的**层级**，在**同一层级中**也是根据**页目录项记录**的**主键大小**顺序排成一个**双向链表**
- B+树的**叶子节点**存储的是**完整的用户记录**（指的是**这个记录中存储了所有列的值（包括隐藏列）**）

具有上面两个特点的**B+树**称为**聚簇索引**。所有**完整的用户记录**都存放在这个**聚簇索引**的**叶子节点**处。这种聚簇索引，不需要我们在MySQL语句中显示使用**INDEX语句**去创建，InnoDB会自动为我们**创建聚簇索引**  
**InnoDB存储引擎**中，**聚簇索引**就是**数据的存储方式**（所有的**用户记录**都存储在了**叶子节点**）。**索引即数据，数据即索引**  

## 二级索引

聚簇索引只能在搜索条件是**主键值**时才发挥作用，如果要以别的列作为搜索条件，可以**多建几颗B+树**，而且不同**B+树**中的数据，采用**不同的排序规则**  

> 比如用c2列的大小作为**数据页**、**页中记录**的排序规则，再建一颗B+树

>  "前言：c1已经是主键了"  
>
> ```shell
> #例子
> mysql> CREATE TABLE index_demo(
>     -> c1 INT,
>     -> c2 INT,
>     -> c3 CHAR(1),
>     -> PRIMARY KEY(c1)
>     -> ) ROW_FORMAT=COMPACT;
> ```

![image-20230423164159110](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423164159110.png)

下面是聚簇索引特点：  
![image-20230423164247987](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423164247987.png)

二级索引说明：  

- 使用**记录c2列**的大小进行**记录**和**页**的排序  
  1. 页（包括**叶子节点**和**内节点**）内的记录，按照**c2列大小**顺序排成一个单向链表，**页内的记录**被划分成**若干个组**，每个组中**c2列值最大**的记录在**页内的偏移量**会被当作**槽**一次存放在**页目录中**（Supremum记录比任何用户记录都大）之后可以在**页目录**中通过**二分法**快速定位到**c2列值**等于**某个值**的记录
  2. 各个**存放用户记录**的**页**也是根据**页中用户记录**的**c2列大小**顺序排成一个**双向链表**
  3. 存放**目录项记录**的页分为不同的**层级**，在**同一层级中**也是根据**页目录项记录**的**c2列大小**顺序排成一个**双向链表**
- B+树的**叶子节点**存储的是**并不是完整的用户记录**，而只是**c2列+主键**这两个列的值
- 目录项记录中不再是**主键+页号**的匹配，而变成了**c2列+页号**的搭配

