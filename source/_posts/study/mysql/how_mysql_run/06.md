---
title: 06B+树索引
description: 06B+树索引
tags:
  - MySQL是怎样运行的
categories:
  - 学习
date: 2023-04-22 15:04:46
updated: 2023-04-22 15:04:46
---

> 学习《MySQL是怎样运行的》，感谢作者！

# 概述

数据页由**7个**组成部分，各个数据页可以组成一个**双向链表**，每个数据页中的记录会按照**主键值从小到大的顺序**组成一个**单向链表**。每个数据页都会为**它里面的记录**生成一个**页目录**，在通过主键查找某条记录的时候可以在**页目录**中使用二分法快速定位到**对应的槽**，然后再**遍历该槽**对应**分组中的记录**即可快速找到**指定**的记录。**页和记录**的关系    

> 页a，页b 可以**不在物理结构上相连**，只要通过**双向链表相关联**即可

![image-20230422205909858](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230422205909858.png)

# 没有索引时进行查找

假设我们要搜索**某个列**等于**某个常数**的情况：  
```SELECT [查询列表] FROM 表名 WHERE 列名 = xxx```

## 在一个页中查找

假设记录极少，所有记录可以**存放到一个页中**  

- 以**主键**位搜索条件：页目录中使用**二分法**快速定位到对应的**槽**，然后在**遍历槽对应分组中的记录**，即可快速找到指定记录
- 其他列作为搜索条件：对于**非主键**，数据页没有为**非主键列**建立所谓的**页目录**，所以**无法通过二分法**快速定位相应的槽。只能**从Infimum依次遍历**单向链表中的每条记录，然后对比，效率极低

## 在很多页中查找

两个步骤：  

- **定位到记录所在的页**
- 从**所在页内**查找相应的记录

**没有索引**情况下，不能快速定位到所在页，只能从**第一页**沿着**双向链表**一直往下找，而如果是主键，每一页则可以在**页目录**二分查找。  
不过由于要**遍历所有页**，所以超级**耗时**

# 索引

```shell
#例子
mysql> CREATE TABLE index_demo(
    -> c1 INT,
    -> c2 INT,
    -> c3 CHAR(1),
    -> PRIMARY KEY(c1)
    -> ) ROW_FORMAT=COMPACT;
```

> 完整的行格式

![image-20230423113811933](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423113811933.png)

简化的行格式  
![image-20230423111720338](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423111720338.png)

- record_type：**记录头信息**的一项属性，表示**记录的类型**。0：普通记录，2：Infimum记录，3：Supremum记录，1还没用过等会再说
- next_record：**记录头信息**的一项属性，表示从当前记录的**真实数据**到**下一条记录真实数据**的距离
- 各个列的值：这里只展示在index_demo表中的**3个列**，分别是c1、c2、c3
- 其他信息：包括**隐藏列**及**记录的额外信息**

改为竖着查看：  
![image-20230423114517255](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423114517255.png)

> 上面图6-4的箭头其实有一点点出入，应该是指向z真实数据第1列那个位置，如下 
> ![image-20230423114716300](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423114716300.png)

## 一个简单的索引方案

思考：在**根据某个条件**查找一些记录，为什么要**遍历所有**的**数据页**呢？因为各个**页**中的记录没有规律，不知道**搜索条件会匹配哪些页**  
思路：为**快速定位**记录所在的**数据页**而建立一个别的目录  

### 有序   

下一个数据页中**用户记录**的**主键值**必须大于上一页**用户记录**的**主键值**  
假设一页只能存放3条记录   

```shell
#插入3条记录
mysql> INSERT INTO index_demo VALUES(1,4,'u'),(3,9,'d'),(5,3,'y');
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0
```

此时页的情况  
**记录组成了单链表**  
![image-20230423120232629](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423120232629.png)

再**插入一条记录**  

```shell
mysql> INSERT INTO index_demo VALUES(4,4,'a');
Query OK, 1 row affected (0.01 sec)
```

(注意，页之间可能**不是连续**的)

![image-20230423120335929](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423120335929.png)

由于页10中**最大记录**是**5**，而页28中有一条记录是**4**，因为5>4，不符合**下一个数据页中用户记录的主键值**必须**大于上一页中用户记录的主键值**，所以在**插入主键值为4的记录时需要伴随着一次记录移动**，也就是把5的记录移动到**页28**中，再把**主键值4**的记录**插入到页10中**  
![image-20230423122233694](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423122233694.png)

这个过程表明，在对页中的记录进行**增删改**操作的过程中，我们必须通过一些诸如**记录移动**的操作来始终保证这个状态一直成立：**下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值**。这个过程也可以称为**页分裂**。

### 给所有的页建立一个目录项

前提：index_demo表中有多条记录的效果  
![image-20230423122443198](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423122443198.png)

1页有16KB，这些页在磁盘上可能并不连续，**要想从这么多页中**根据**主键值**快速定位**某些记录所在的页**，需要给他们编制一个**目录**，每个页对应一个**目录项**，每个目录项包括**两部分**：  

- 页的**用户记录**中**最小的主键值**，用**key**表示
- 页号，**page_no**表示 

![image-20230423122846720](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423122846720.png)

假设我们此时把**目录项**在**物理存储器上连续存储**，比如放到数组中，此时就可以**根据主键值**快速查找**某条记录**  

1. 先用二分法快速定位主键20的记录在**目录项3中**（因为**12<20<209**)，对应页是9

2. 根据前面说的方式在**页9中**定位具体记录    

   > 先在**页目录**中二分查找，找到对应的组后**沿链表遍历**

这个目录项的别名：**索引**

## InnoDB中的索引方案

### 上述方案的问题

- InnoDB使用页作为**管理存储空间**的基本单位，即**只能保证16KB**的**连续存储空间**，如果记录非常多，则需要的**连续存储空间**就**非常大**
- **增删改**是很频繁的，如果页28的记录全部移除，那么目录项2就没有出现的必要，即**要删除目录项2**，那么所有的**目录项**都需要**左移**/或者不移动，作为冗余**放到目录项列表**中，浪费空间

### 方案

复用之前存储用户记录的**数据页**来存储目录项，用了和**用户记录**进行区分，把这些**用来表示目录项**的记录称为**目录项记录**。如何区分一条记录是**普通用户记录**，还是**目录项记录**：使用**记录头信息**中的**record_type**属性  

- 0：普通用户记录
- 1：目录项记录
- 2：Infimum记录
- 3：Supremum记录

**将目录项放到数据页中**  
![image-20230423140229838](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423140229838.png)

**新分配了一个编号为30的页来专门存储目录项记录**  
**目录项记录**和**普通的用户记录**的不同点  

- 目录项记录的**record_type**值为1，普通用户记录**record_type**值为0

- 目录项记录只有**主键值**和**页的编号**这两个列，而普通用户记录的**列**是用户自己定义的，可能包含许多列，另外还有**InnoDB**自己添加的**隐藏列**

- **记录头信息**中有一个名为**min_rec_flag**的属性，只有目录项记录的min_rec_flag属性才可能为1，普通记录的min_rec_flag属性都是0  

  > B+ 树中**每层**非叶子节点中的**最小的目录项**记录都会添加该标记

**其他**：  
它们用的是**一样的数据页**(**页面类型**都是Ox45BF ，这个属性在File Header 中)；页的**组成结构**也是一样的〈就是我们前面介绍过的**7 个部分**)；都会为主键值生成**Page Directory**（页目录）从而在**按照主键值进行查找**时可以**使用**
**二分法**来加快查询速度。

### 举例

#### 单个 目录项记录页

![image-20230423140327842](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423140327842.png)

其中，页30中存储的**主键值**分别为**1**，**5**，**12**，**209**  
假设我们现在要查找**主键值为20的记录**：  

1. 先到**存储目录项记录的页（这里是页30）**中，（由于有**页目录**）通过二分法**快速**定位到对应的**目录项记录**，因为12<20<209，所以定位到对应的**用户记录**所在的页就是**页9**
2. 再到**存储用户记录**的**页9**中根据**二分法**（**由于有页目录）**）快速定位到**主键值为20**的用户记录

**目录项记录**中只**存储主键值**和**对应的页号**，存储空间极小，但一个页只有16KB，存放的**目录项记录**有限。如果表中数据太多（**页太多**），以至于**一个数据页**不足以存放所有的**目录项记录**

#### 多个 目录项记录的页

解决方案：**新增一个存储目录项记录的页**  


![image-20230423141605646](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423141605646.png)

此时再进行查找

- 确定存储目录项记录的页  
  现在**存储目录项记录的页**有2个，即页30和页32。又因为页30表示的目录项**记录主键值**范围是**[1，320)**，页32表示的**目录项记录主键值**范围 **> 320**。所以确定主键值为20的记录**对应的目录项记录**在页30中
- 按照**单个** **目录项记录页**的方案查找

## 多个目录项记录页

如果数据再增加，则再**生成存储更高级目录项记录**的**数据页**  
![image-20230423142254862](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423142254862.png)

无论是**存放用户记录**的数据页，还是**存放目录项记录**的数据页，都放到B+树数据结构中，我们也将这些**数据页**称为**B+树的节点**  
如图，我们真正的**用户记录**其实都存放在B+树**最底层的节点上**，这些节点也称为**叶子节点**或**页节点**，其余用来存放**目录项记录**的节点称为**非叶子节点**或者**内节点**，其中B+树最上边的那个节点也称为**根节点**
![image-20230423142809455](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423142809455.png)

这里我们规定，**最下面**那层（存放**用户记录**的那层）为0层，之后**层级**依次往上加。  
这里我们假设所有存放**用户记录**的**叶子节点**所代表的**数据页**可以存放100条**用户记录**（16KB=16 * 1024 ≈10000 字节，差不多一条记录100字节），假设所有存放**目录项记录**的**内节点**所代表的**数据页**可以存放1000条**目录项记录**（10000字节，假设**1个目录项10字节**），那么如果  

- 如果B+树有1层，那么只有一个用于存放用户记录的节点，那么能存放100条用户记录（1百）
- 如果B+树有2层，那么能存放 1000 * 100=100,000条用户记录(10万)
- 如果B+树有3层，那么能存放 1000 * 1000 * 100=100,000,000条用户记录(1亿)
- 如果B+树有4层，那么能存放 1000 * 1000 * 1000 * 100=100,000,000,000条用户记录 (1000亿)

所以**一般情况**下，我们用到的**B+树不会超过4层**。  

当我们要通过**主键值**查找**某条记录  **

- **最多只需要进行**4个页面内的查找（查找**3个存储目录项记录**的页和**1个存储用户记录**的页）  
- 每个页面内存在**PageDirectory（页目录）**，所以在页面内**也可以**通过**二分法**快速定位记录  

> PageHeader中，有一个名为**PAGE_LEVEL**的属性，代表着**这个数据页**作为**节点**在B+树中的层级

### 聚簇索引

前面介绍的B+树**本身就是一个记录**，或者说**本身就是一个索引**，有以下两个特点  

- 使用**记录主键值**的大小进行**记录**和**页**的排序  
  1. 页（包括**叶子节点**和**内节点**）内的记录，按照**主键大小**顺序排成一个单向链表，**页内的记录**被划分成**若干个组**，每个组中**主键值最大**的记录在**页内的偏移量**会被当作**槽**一次存放在**页目录中**（Supremum记录比任何用户记录都大）之后可以在**页目录**中通过**二分法**快速定位到**主键列**等于**某个值**的记录
  2. 各个**存放用户记录**的**页**也是根据**页中用户记录**的**主键大小**顺序排成一个**双向链表**
  3. 存放**目录项记录**的页分为不同的**层级**，在**同一层级中**也是根据**页目录项记录**的**主键大小**顺序排成一个**双向链表**
- B+树的**叶子节点**存储的是**完整的用户记录**（指的是**这个记录中存储了所有列的值（包括隐藏列）**）

具有上面两个特点的**B+树**称为**聚簇索引**。所有**完整的用户记录**都存放在这个**聚簇索引**的**叶子节点**处。这种聚簇索引，不需要我们在MySQL语句中显示使用**INDEX语句**去创建，InnoDB会自动为我们**创建聚簇索引**  
**InnoDB存储引擎**中，**聚簇索引**就是**数据的存储方式**（所有的**用户记录**都存储在了**叶子节点**）。**索引即数据，数据即索引**  

### 二级索引

聚簇索引只能在搜索条件是**主键值**时才发挥作用，如果要以别的列作为搜索条件，可以**多建几颗B+树**，而且不同**B+树**中的数据，采用**不同的排序规则**  

> 比如用c2列的大小作为**数据页**、**页中记录**的排序规则，再建一颗B+树

>  "前言：c1已经是主键了"  
>
> ```shell
> #例子
> mysql> CREATE TABLE index_demo(
>     -> c1 INT,
>     -> c2 INT,
>     -> c3 CHAR(1),
>     -> PRIMARY KEY(c1)
>     -> ) ROW_FORMAT=COMPACT;
> ```

![image-20230423164159110](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423164159110.png)

下面是聚簇索引特点：  
![image-20230423164247987](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423164247987.png)

二级索引说明：  

- 使用**记录c2列**的大小进行**记录**和**页**的排序  
  1. 页（包括**叶子节点**和**内节点**）内的记录，按照**c2列大小**顺序排成一个单向链表，**页内的记录**被划分成**若干个组**，每个组中**c2列值最大**的记录在**页内的偏移量**会被当作**槽**一次存放在**页目录中**（Supremum记录比任何用户记录都大）之后可以在**页目录**中通过**二分法**快速定位到**c2列值**等于**某个值**的记录
  2. 各个**存放用户记录**的**页**也是根据**页中用户记录**的**c2列大小**顺序排成一个**双向链表**
  3. 存放**目录项记录**的页分为不同的**层级**，在**同一层级中**也是根据**页目录项记录**的**c2列大小**顺序排成一个**双向链表**
- B+树的**叶子节点**存储的是**并不是完整的用户记录**，而只是**c2列+主键**这两个列的值
- 目录项记录中不再是**主键+页号**的匹配，而变成了**c2列+页号**的搭配

B+树如下  
![image-20230423165035649](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423165035649.png)

#### 举例

假设要查找c2=4的记录，可以使用上面的B+树。由于c2没有唯一性约束，所以可能会有很多条：我们只需要在**该B+树的叶子节点处**定位到**第一条**满足搜索条件c2=4的那条，然后由**记录**组成的单向链表**一直向后扫描**即可。另外，**各个叶子节点**组成了**双向链表**，搜索完了**本页面的记录**后可以顺利跳到**下一个页面**中的**第一条记录**，然后沿着记录组成的**单向链表**向后扫描  

##### 查找过程

1. 确定第一条符合c2=4条件的**目录项记录**所在的**页**  

   > 根据**根页面（44）**可以快速定位到第一条符合c2=4条件的目录项记录所在页为页42（因为2<4<9)

2. 通过第一条符合c2=4条件的目录项记录**所在的页面**确定第一条符合c2=4条件的**用户记录**所在的**页**  

   > 根据页42可以快速定位（通过**页目录**）到第一条符合条件的**用户记录**所在页为34或35，因为2<4<=4

3. 在**真正存储**第一条符合c2=4条件的**用户记录的页**中定位到具体的记录  

   > 页34和页35中定位到具体的用户记录（如果页34使用**页目录**定位到**第一条**符合条件的用户记录，就不需要再到35中去再定位，因为直接一直往后查找到**不等的记录**即可）

4. 由于这个B+树的叶子节点的记录**只存储了c2和c1（即主键）**两个列。在叶子节点定位到**第一条**符合条件的那条用户记录之后，我们需要根据该纪录中的**主键信息**，到**聚簇索引**中查找到**完整的用户记录**，这个通过**携带主键信息**到**聚簇索引**中重新定位**完整的用户记录**的过程也称为**回表**  。  
   然后再返回到这棵B+ 树的**叶子节点**处，找到刚才定位到的**符合条件**的那条用户记录，并沿着记录组成的**单向链表向后**继续搜索其他也满足c2=4的记录**，每找到一条**的话就继续进行回表操作。重复这个过程，**直到**下一条记录**不满足c2 =4**的这个条件为止.

> 如果把完整的用户记录放到叶子节点是可以不用回表，但是太占地方了

因为这种以**非主键列的大小为排序规则**而**建立的B+ 树**需要**执行回表**操作**才可以定位到完整**的用户记录，所以**这种B+ 树**也称为**二级索引(Secondary Index)** 或**辅助索引**。由于我们是以c2 列的大小作为B+ 树的排序规则，所以我们也称**这棵B+ 树**为**为c2 列建立的索引**，把**c2列称为索引列**。**二级索引记录**和**聚簇索引记录**使用的是**一样的记录行格式**，只不过**二级索引**记录存储的列**不像聚簇索引记录那么完整**。  
把**聚簇索引**或者**二级索引**的**叶子**节点中的记录称为**用户记录**。为了区分，也把**聚簇索引叶子节点**中的记录称为**完整的用户记录**，把**二级索引叶子节点**中的记录称为**不完整的用户记录**  

> 如果为一个**存储字符串**的列**建立索引**，别忘了前面说的**字符集和比较规则**，字符串也是可以**比较大小**的

### 联合索引

同时以**多个列**的大小作为**排序规则**，也就是同时为**多个列**建立索引，含义：  

1. 先把各个**记录**和**页**按照**c2列**进行排序
2. 记录的c2列相同的情况下，再采用c3进行排序  

![image-20230423171548379](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423171548379.png)

1. 每条**目录项记录**都由c2列、c3列、页号这3个部分组成。各条记录先按照**c2列的值**进行排序。如果记录的c2列**相同**，则按照**c3列的值**进行排序  

   > 这里说的是极特殊的情况，也就是c2列相同的记录有**很多很多条**，导致**好几个页都有c2 = x**的记录，而且其中c3列的值还不同，那么就会出现**目录项记录页**中的目录项c2相同而c3不相同

2. B+树**叶子节点**处的用户记录由c2列、c3列、和主键c1列组成

**以c2 和c3 列的大小为排序规则**建立的B+ 树称为**联合索引**，也称为**复合索**
**引**或**多列索引**。它**本质**上也是一个**二级索引**，它的索引列包括**c2、c3**.需要注意的是"**以c2和c3列的大小为排序规则建立联合索引**"和"**分别为c2和d 列建立索引**" 的表述是不同的， 不同点如下：

1. 建立联合索引**只会**建立如图6-15 所示的**一棵**B+ 树
2. 为c2 和c3 列分别建立索引时，则会**分别**以c2 和c3 列的大小为排序规则建立**两棵B+ 树**

## Inno中B+树索引的注意事项

### 根页面万年不动窝

前面为了理解方便，我们先把存储**用户记录**的**叶子节点**都画出来，然后再画出存储**目录项记录**的**内节点**。而实际上是这样的：  

1. 每当为**某个表**创建一个**B+树索引**（聚簇索引不是人为创建的，默认就存在）时，**都**会为这个索引创建一个**根节点页面**。  
   一开始表中**没有数据**的时候，每个B+树索引对应的**根节点**中既没有**用户记录**，也没有**目录项记录**
2. 随后向表中插入**用户记录**时，先把用户记录存储到这个**根节点**中
3. 当**根节点可用空间用完**时，继续插入记录，此时会将**根节点中的所有记录复制到一个新分配的页**（比如页a）中，然后对这个新页进行**页分裂**操作，得到**另一个新页**（比如页b）[因为一个页放不下，所以还要这个新页]。这时新插入的**记录**会**根据键值**（也就是**聚簇索引**中的主键值，或者**二级索引**中对应的**索引列**的值）的大小分配到**页a**或者**页b**。根节点此时，便升级为**存储目录项记录**的页，也就需要把**页a**和**页b**对应的**目录项记录**插入到**根节点**中

在这个过程中，需要特别注意的是， 一个**B+ 树索引的根节点自创建之日**起便**不会再移动**(也就是**页号不再改变**)。  
由于这个特性，只要我们对**某个表**建立一个**索引**，那么它的**根节点的页号便会被**记录到某个地方，后续凡是InnoDB引擎需要用到这个索引，会从那个**固定的地方**取出**根节点的页号**，从而访问这个索引  

> "存储某个索引的根节点在哪个页面中"，就是传说中的**数据字典**中的一项信息

> 这里还有一个问题，书上没说，就是根节点作为a，b页的存储目录项记录的页，一旦后面页越来越多，根节点放不下了，接下来  
> 我猜是这样的，也是再新分配一个页X，然后对页X页分裂，得到页Y。把根节点此时的所有目录项全复制到页X，然后新插入的目录项记录根据键值分配到页X，或Y，然后根节点又变为**存储目录项记录**的页

### 内节点中目录项记录的唯一性

目前为止，我们说**B+树索引**的**内节点**中，**目录项记录**的内容是**索引列**加**页号**的搭配，但是这个搭配对**二级索引**来说有点儿不太严谨。以下面这个表为例（c1是主键，c2是二级索引）  

| c1   | c2   | c3   |
| ---- | ---- | ---- |
| 1    | 1    | 'u'  |
| 3    | 1    | 'd'  |
| 5    | 1    | 'y'  |
| 7    | 1    | 'a'  |

如果**二级索引**中，目录项记录的内容只是**索引列+页号**的匹配，那么为c2列建立索引后的B+树如下图6-16  
![image-20230423232353741](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423232353741.png)

如果此时再插入一条记录 c1=9，c2=1，c3='c'，那么在修改为c2列建立的**二级索引**对应的**B+树**时：由于页3中存储的目录项记录由**c2列+页号**构成，页3中两条目录项记录**对应的c2列都是1**，而新插入的这条记录中，c2列也是1，那么这条新插入的记录应该放在页4还是页5？  
为了保证B+树**同一层内节点**的**目录项记录**除了**页号**这个字段以外是**唯一**，所以**二级索引**的**内节点**的**目录项记录**内容实际上由3部分构成：  **索引列的值**，**主键值**，**页号**  ，如上**图6-17**

> 插入记录（9，1，’c'）时，由于页3 中存储的目录项记录是由**c2 列**+ **主键**+**页号**构成的， 因此可以先把**新记录的c2 列**的值和**页3 中各目录项**记录的c2 列的值进行比较， 如果**c2 列的值**相同，可以**接着比较主键值**。因为B+ 树**同一层中不同目录项记录**的c2 列+主键的值肯定是不一样的，所以最后肯定**能定位到唯一的一条目录项记录**。
> 在本例中， 最后确定新记录应该插入到页5 中

对于二级索引，先按照**二级索引列**的值进行排序，如果相同，再按照**主键值**进行排序。所以，为c2列建立索引，相当于为（c2，c1）列建立了一个**联合索引**。另外，对于**唯一二级索引**来说（当我们为**某个列**或**列组合**声明**UNIQUE**属性时，便会为这个列或组合建立**唯一索引**），也可能出现多条记录**键值相同**的情况（1. 声明为UNIQUE的列可能存储多个NULL 2. 后面要讲的MVCC服务），唯一二级索引的**内节点的目录项记录**也会包含记录的主键值  

> 注意，书上没有讲到**删除的情况**，也就是假设有一种情形：索引值1的行被删了，后面又重新添加了。我的理解是不会出现两条索引值一样的记录在树上（根据前面记录行的delete_flag，有可能重复，但是我猜会覆盖掉，所以这里没讲到那个情况，暂时没找到资料证明）

### 一个页面至少容纳2条记录

如果一个**大的目录**中只存放**一个子目录**，那么**目录层级**会非常多，而且最后那个**存放真正数据**的**目录**中只能存放**一条记录**  
如果让B+树的**叶子节点只存储一条**记录，让内节点存储多条记录，也还是可以发挥B+树作用的。为了避免B+树的层级增长过高，要求**所有数据页**都**至少可以容纳2条记录**（也就是说，会极力避免因为列值过大、或者过多导致容纳不了2条记录）  

> InnoDB对列的数量有所限制，而如果在最大限制下，结合04章的结论：  
> 如果一条记录的某个列中存储的数据**占用字节数非常多**，导致一个页**没有办法**存储**两条记录**，该列就可能会成为溢出列 

## MyISAM中的索引方案简介

