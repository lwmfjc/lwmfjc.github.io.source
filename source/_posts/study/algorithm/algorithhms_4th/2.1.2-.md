---
title: 算法红皮书 2.1.2-
description: '选择排序'
categories:
  - 学习
tags:
  - 算法红皮书(第四版)
date: 2022-04-23 15:54:21
updated: 2022-04-23 23:38:21
---

# 排序

## 初级排序算法

### 选择排序

- 命题A。对于长度为N 的数组，选择排序需要大约N2/2 次比较和N 次交换。

- 代码

  ```java
  public class Selection
  {
  	public static void sort(Comparable[] a)
  	{
  		// 将a[]按升序排列
  		int N = a.length;
  		// 数组长度
  		for (int i = 0; i < N; i++)
  		{
  			// 将a[i]和a[i+1..N]中最小的元素交换
  			int min = i;
  			// 最小元素的索引
  			for (int j = i+1; j < N; j++)
  			if (less(a[j], a[min])) min = j;
  			exch(a, i, min);
  		}
  	}
  	// less()、exch()、isSorted()和main()方法见“排序算法类模板”
  }
  ```

- 特点

  - 运行时间与输入无关，即输入数据的初始状态（比如是否已排序好等等）不影响排序时间
  - 数据移动是最少的（只使用了N次交换，交换次数和数组的大小是线性关系

### 插入排序

- 命题B。对于随机排列的长度为N 且主键不重复的数组，平均情况下插入排序需要～ N2/4 次比较以及～ N2/4 次交换。最坏情况下需要～ N2/2 次比较和～ N2/2 次交换，最好情况下需要N-1次比较和0 次交换。

- 代码

  ```java
  public static void sort(Comparable[] a) {
          int N = a.length;
          //将下表为 n-1的数，依次和n-2,n-3一直到0比较，
          //所以第二层for只走到1，因为0前面没有值
          //如果比前面的值小，就进行交换
          for (int i = 1; i < N; i++) {
              for (int j = i; j > 0 && less(a[j], a[j - 1]); j--) {
                  exch(a, j, j - 1);
              }
          }
      }
  ```

- 当倒置的数量很小时，插入排序比本章中的其他任何算法都快

- > 命题C。插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。

- > 性质D。对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数

### 希尔排序

- 希尔排序的思想是使数组中任意间隔为h的元素都是有序的，这样的数组称为h有序数组，一个h有序数组就是h个互相独立的有序数组编制在一起组成的数组
- 
