---
title: InnoDB数据页结构
description: InnoDB数据页结构
tags:
  - MySQL是怎样运行的
categories:
  - 学习
date: 2023-04-21 10:35:29
updated: 2023-04-21 10:35:29
---

> 学习《MySQL是怎样运行的》，感谢作者！

# 不同类型的页简介

页是**InnoDB管理存储空间**的基本单位，1个页的大小一般是16KB

> InnoDB为了不同目的设计多种不同类型的页，包括**存放表空间头部信息**
> 的页、**存放Change Buffer 信息**的页、**存放INODE信息**的页、**存放undo 日志信息**的页

这里说的是**存放表中记录**的那种类型的页，这种**存放记录**的页称为**索引页**（INDEX页）  

> 暂时称之为**数据页**  

# 数据页结构快览

1个页有16KB，这部分存储空间被划分为了多个部分（7部分），不同部分有不同的功能  
![image-20230421104616950](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421104616950.png)

| 名称               | 中文名                     | 占用空间 | 大小                 |
| ------------------ | -------------------------- | -------- | -------------------- |
| File Header        | 文件头部                   | 38 字节  | 页的一些通用信息     |
| Page Header        | 页面头部                   | 56 字节  | 数据页专有的一些信息 |
| Infimum + Supremum | 页面中的最小记录和最大记录 | 26 字节  | 两个虚拟的记录       |
| User Records       | 用户记录                   | 不确定   | 用户存储的记录内容   |
| Free Space         | 空闲空间                   | 不确定   | 页中尚未使用的空间   |
| Page Directory     | 页目录                     | 不确定   | 某些记录的相对位置   |
| File Trailer       | 文件尾部                   | 8 字节   | 校验页是否完整       |

# 记录在页中的存储

每插入一条记录，从**Free Space**申请一个记录大小的空间，并**将这个空间划分到UserRecords**部分。当FreeSpace部分的空间全部被UserRecords部分替代掉后，意味着该页用完。如果再插入，就需要申请新的页  


![image-20230421105227745](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421105227745.png)

## 记录头信息的秘密

```shell
mysql> CREATE TABLE page_demo(
    -> c1 INT,
    -> c2 INT,
    -> c3 VARCHAR(10000),
    -> PRIMARY KEY(c1)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
Query OK, 0 rows affected (0.03 sec)
```

![image-20230421105707019](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421105707019.png)

| 名称         | 大小（比特） | 描述                                                         |
| ------------ | ------------ | ------------------------------------------------------------ |
| 预留位1      | 1            | 没有使用                                                     |
| 预留位2      | 1            | 没有使用                                                     |
| deleted_flag | 1            | 标志该记录是否被删除                                         |
| min_rec_flag | 1            | B+ 树中每层非叶子节点中的最小的目录项记录都会添加该标记      |
| n_owned      | 4            | 一个页面中的记录会被分成若干个组，每个组中有一个记录是"带头大哥“，其余的记录都是"小弟"。带头大哥"记录的n_owned值代表该组中所有的记录条数，"小弟"记录的n_owned值都为0 |
| heap_no      | 13           | 表示当前记录在页面堆中的相对位置                             |
| record_type  | 3            | 表示当前记录的类型，0表示普通记录. 1 表示B+ 树非叶节点的目录项记录. 2 表示Infimum 记录. 3 表示Supremum 记录 |
| next_record  | 16           | 表示下一条记录的相对位置                                     |

简化一下（忽略其他**非讲解**的部分信息）  
![image-20230421110425298](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421110425298.png)

```shell
#插入4条记录
mysql> INSERT INTO page_demo VALUES(1,100,'aaaa'),(2,200,'bbbb'),(3,300,'cccc'),(4,400,'dddd');
Query OK, 4 rows affected (0.01 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

UserRecords部分的存储结构  
![image-20230421110623788](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421110623788.png)

### deleted_flag

标记当前记录是否删除：0表示没有被删除，1表示记录被删除  

> 被删除的记录不从磁盘溢出，因为移除后还需要在磁盘上**重新排列**其他的记录，带来性能消耗  
> 被删除掉的记录会组成一个垃圾链表，记录在这个链表中占用的空间称为**可重用空间**，如果之后有新纪录插入到表中，就可能**覆盖掉被删除的记录所占用的存储空间**  
> delete_flag设置为1和将被删除的记录加入到垃圾链表其实是两个阶段，后面介绍undo日志会详细讲解删除操作的详细执行过程



# PageDirectory（页目录）

# PageHeader（页面头部）

# FileHeader（文件头部）

# FileTrailer（文件尾部）

