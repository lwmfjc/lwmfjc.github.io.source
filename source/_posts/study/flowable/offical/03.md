---
title: 'Flowable-03-api'
description: 'api'
categories:
  - 学习
tags:
  - flowable
date: 2022-04-29 09:57:47
updated: 2022-04-29 10:37:47
---

### 流程引擎API和服务

引擎API是与Flowable交互的常见方式，主要起点是ProcessEngine，可以通过配置（Configuration章节）中描述的多种方式创建。

从ProcessEngine获取包含工作流/BPM方法的各种服务。ProcessEngine和服务对象是线程安全的

![api.services](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/api.services.png)

下面是通过processEngine获取各种服务的方法

```java
ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();

RuntimeService runtimeService = processEngine.getRuntimeService();
RepositoryService repositoryService = processEngine.getRepositoryService();
TaskService taskService = processEngine.getTaskService();
ManagementService managementService = processEngine.getManagementService();
IdentityService identityService = processEngine.getIdentityService();
HistoryService historyService = processEngine.getHistoryService();
FormService formService = processEngine.getFormService();
DynamicBpmnService dynamicBpmnService = processEngine.getDynamicBpmnService();
```

ProcessEngines.getDefaultProcessEngine()在第一次调用时初始化并构建流程引擎，然后返回相同的流程引擎

ProcessEngines类将扫描所有flowable.cfg.xml和flowable-context.xml文件。

> 对于所有 flowable.cfg.xml 文件，流程引擎将以典型的 Flowable 方式构建：ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream).buildProcessEngine()。
>
> 对于所有 flowable-context.xml 文件，流程引擎将以 Spring 方式构建：首先创建 Spring 应用程序上下文，然后从该应用程序上下文中获取流程引擎。

> The **RepositoryService** is probably the first service needed when working with the Flowable engine.

该服务**(RepositoryService)**提供用于管理和操作部署**deployments**和流程定义的操作

- 查询引擎已知的部署和流程定义
- 暂停和激活作为一个整体或特定流程定义的部署。挂起意味着不能对它们执行进一步的操作，而激活则相反并再次启用操作
- 检索各种资源，例如引擎自动生成的部署或流程图中包含的文件
- 检索流程定义的 POJO 版本，该版本可用于使用 Java 而不是 XML 来内省流程

RepositoryService主要是关于静态信息（不会改变的数据，或者至少不会改变太多），而RuntimeService处理启动流程定义的*新流程实例* 

- 流程定义定义了流程中不同步骤的结构和行为，流程实例是此类流程定义的一次执行

- 对于每个流程定义，通常有许多实例同时运行

- Runtime也用于检索和存储**流程变量**

- Runtimeservice还可以用来查询流程实例和执行(executions)

  > Executions are a representation of the 'token' concept of BPMN 2.0.
  > 执行是指向流程实例当前所在位置的指针

- 只要流程实例正在等待外部触发器并且流程需要继续，就会使用 RuntimeService

- 流程实例可以有各种等待状态，并且该服务包含各种操作以向实例发出“信号”，即接收到外部触发器并且流程实例可以继续

需要由系统的人类用户执行的任务是BPM引擎（如Floable）的核心，围绕任务的所有内容都在TaskService中进行分组

- 查询分配给用户或组的任务
- 创建新的独立任务（与流程实例无关）
- 任务被分配给哪个用户或哪些用户，以及让这些用户以某种方式参与该任务
- 要求并完成一项任务，声明意味着某人决定成为该任务的受让人**assignee** 

IdentityService支持组和用户的管理（创建、更新、删除、查询）

FormService是可选服务，引入了启动表单（**start form**）和任务表单(**a task form**)的概念

> **HistoryService**公开了 Flowable 引擎收集的所有历史数据。在执行流程时，引擎可以保留很多数据（这是可配置的），例如流程实例的启动时间，谁做了哪些任务，完成任务花了多长时间，每个流程实例中遵循的路径，等等。

使用Flowable 编写自定义应用程序时，通常不需要**ManagementService 。**它允许检索有关数据库表和表元数据的信息。此外，它还公开了作业的查询功能和管理操作

**DynamicBpmnService**可用于更改流程定义的一部分，而无需重新部署它。例如，您可以更改流程定义中用户任务的受理人定义，或更改服务任务的类名。

### 异常策略

Flowable 中的基本异常是 org.flowable.engine.FlowableException

Flowable的一些异常子类

- FlowableWrongDbException：当 Flowable 引擎发现数据库架构版本和引擎版本不匹配时抛出。
- FlowableOptimisticLockingException：当并发访问同一数据条目导致数据存储发生乐观锁定时抛出。
- FlowableClassLoadingException：当请求加载的类未找到或加载时发生错误时抛出（例如 JavaDelegates、TaskListeners ......）。
- FlowableObjectNotFoundException：当请求或操作的对象不存在时抛出。
- FlowableIllegalArgumentException：异常表明在 Flowable API 调用中提供了非法参数，在引擎配置中配置了非法值，或者提供了非法值，或者在流程定义中使用了非法值。
- FlowableTaskAlreadyClaimedException：当任务已被声明时抛出，当 taskService.claim(...) 被调用时

### 查询接口

引擎查询数据有两种方式：the query API and native queries

- queryAPi允许使用fluent API编写完全类型安全的查询，例如

  ```java
  List<Task> tasks = taskService.createTaskQuery()
      .taskAssignee("kermit")
      .processVariableValueEquals("orderId", "0815")
      .orderByDueDate().asc()
      .list();
  ```

- native queries
  （返回类型由您使用的查询对象定义，数据映射到正确的对象[比如任务、流程实例、执行等，且您必须使用在数据库中定义的表明和列名]）。如下，可以通过api检索表名等，使依赖关系尽可能小

  ```java
  List<Task> tasks = taskService.createNativeTaskQuery()
    .sql("SELECT count(*) FROM " + managementService.getTableName(Task.class) +
        " T WHERE T.NAME_ = #{taskName}")
    .parameter("taskName", "gonzoTask")
    .list();
  
  long count = taskService.createNativeTaskQuery()
    .sql("SELECT count(*) FROM " + managementService.getTableName(Task.class) + " T1, " +
        managementService.getTableName(VariableInstanceEntity.class) + " V1 WHERE V1.TASK_ID_ = T1.ID_")
    .count();
  ```

### 变量



### 瞬态变量

### 表达式

### 表达式函数

### 单元测试

### 调试单元测试

### Web应用程序中的流程引擎

