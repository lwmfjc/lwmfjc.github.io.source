---
title: 07B+数索引的使用
description: 07B+数索引的使用
tags:
  - MySQL是怎样运行的
categories:
  - 学习
date: 2023-04-24 14:32:22
updated: 2023-04-24 14:32:22
---

> 学习《MySQL是怎样运行的》，感谢作者！



# InnoDB存储引擎的B+树索引：结论

- **每个索引**对应一颗B+树。B+树有好多层，**最下边一层**是**叶子节点**，其余是**内节点**。所有**用户记录**都存在B+树的**叶子节点**，所有**目录项记录**都存在内节点
- InnoDB 存储引擎会**自动为主键建立聚簇索引**(如果**没有显式指定主键**或者**没有声明不允许存储NULL的UNIQUE 键**，它会自动添加主键) ， **聚簇索引**的**叶子节点**包含**完整的用户记录**
-  我们可以为感兴趣的列建立**二级索引**，二级索引的叶子节点包含的用户记录由**索引列**
  **和主键**组成。如果想通过二级索引查找完整的用户记录，需要执行**回表**操作， 也就是在通过二级索引**找到主键值之后**，再到**聚簇索引**中查找完整的用户记录
- B+ 树中的**每层节点**都按照**索引列的值从小到大的顺序排序**组成了**双向链表**，而且每个**页内的记录**(无论是**用户记录**还是**目录项记录**)都按照索引列的值从小到大的顺序形成了一个单向链表。如果是联合索引， 则**页面**和**记录** **先**按照索引列中前面的列的值排序：**如果该列的值相同**，**再按照索引列中后面的列的值排序**。比如， 我们对列c2 和c3建立了联合索引 **idx_c2_c3(c2， c3)**，那么该索引中的页面和记录就**先按照c2 列**的值进行排序；**如果c2 列的值相同**， **再按照c3** 列的值排序
- 通过索引查找记录时，是**从B+ 树的根节点开始一层一层向下搜索的**。由于每个页面(无论是**内节点页面**还是**叶子节点页面**〉中的记录都划分成了**若干个组**， 每个组中**索引列值最大的记录**在**页内的偏移量**会被当作**槽**依次存放在**页目录中**(当然， 规定Supremum 记录比任何用户记录都大) ，因此可以在**页目录中通过二分法**快速定位到**索引列等于某个值的记录**  

>  如果大家在阅读上述结论时哪怕有点疑惑， 那么下面的内容就不适合你，请回过头去反复阅读前面的章节

# B+树索引示意图的简化

```shell
#创建新表
mysql> CREATE TABLE single_table(
      id INT NOT NULL AUTO_INCREMENT,
      key1 VARCHAR(100),
      key2 INT,
      key3 VARCHAR(100),
      key_part1 VARCHAR(100),
      key_part2 VARCHAR(100),
      key_part3 VARCHAR(100),
      common_field VARCHAR(100),
      PRIMARY KEY (id),
      KEY idx_key1(key1),
      UNIQUE KEY uk_key2(key2),
      KEY idx_key3(key3),
      KEY idx_key_part(key_part1,key_part2,key_part3)
      ) Engine=InnoDB CHARSET = utf8;
```

如上，建立了**1个聚簇索引**，**4个二级索引**  

- 为id列建立的聚簇索引
- 为key1列建立的idx_key1二级索引
- 为key2列建立的uk_key2二级索引，而且该索引是**唯一二级索引**
- 为key3列建立的idx_key3二级索引
- 为key_part1、key_part2、key_part3列建立的**idx_key_part二级索引**，是一个**联合索引**

接下来为这个表**插入10,000行记录**  
**除了id，其余的列取随机值**：该表后面会频繁用到  

> 需要用程序写，这里暂时跳过（不会...，书上也没写）

回顾：B+树包括**内节点**和**叶子节点**，以及**各个节点中的记录**。B+树其实是一个**矮矮的大胖子**，能够**利用B+树快速地定位记录**，下面简化一下B+树的示意图：  

- 忽略**页结构**，直接把所有**叶子节点中的记录**放一起
- **为了方便**，把**聚簇索引叶子节点**的记录称为**聚簇索引记录**，把**二级索引叶子节点**称为**二级索引记录**

> **回顾一下**：  
>
> 核心要点：把**下一层**每一页的**最小值**，放到**上一级**的**目录项记录**，以**key值+页号**这样的组合存在
>
> ![image-20230423142254862](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423142254862.png)

**精简**：  

![image-20230424224802689](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230424224802689.png)

如上，**聚簇索引**记录是按照**主键值**由小到大的**顺序排列**的    
如下图，通过B+树**定位到id值为1438**的记录  
![image-20230424231409778](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230424231409778.png)

**二级索引idx_key1**对应的B+树中**保留了叶子结点的记录**。以key1排序，如果key1相同，则按照id列排序  
![image-20230424231612980](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230424231612980.png)

> **为了方便**，把**聚簇索引叶子节点**的记录称为**聚簇索引记录**，把**二级索引叶子节点**称为**二级索引记录**

如果要查找**key1值**等于**某个值**的**二级索引**记录，通过**idx_key1**对应的B+树，可以很容易定位到第一条**key1列的值**等于**某个值**的二级索引记录，然后**沿着单向链表**向后扫描即可。  
![image-20230424234609722](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230424234609722.png)

# 索引的代价

## 空间上的代价

每建立**一个索引**，都要为他建立**一颗**B+树。每**一颗B+树**的每一个节点都是**一个数据页**（一个数据页默认占用16KB），而一颗**很大**的B+树由许多数据页组成，这将占用很大的片存储空间

## 时间上的代价

- 每当对表中数据进行**增上改查**时，都要**修改各个B+树**索引
- 执行**查询语句**前，都要生成一个**执行计划**。一般情况下，**一条查询语句**在执行过程中**最多用到一个二级索引**（有例外，10章），在生成执行计划时需要**计算**使用**不同索引**执行查询时所需要的**成本**，最后选取**成本最低**的那个索引执行查询（12章：**如何计算查询成本**）==> 索引太多导致**分析时间过长**  

## 总结

索引越多，存储空间越多，**增删改**记录或者**生成执行计划时**性能越差  
为了建立**又好又少**的索引，得先了解**索引**在**查询执行期间**到底是如何发挥作用的  

# 应用B+树索引

对千某个查询来说，最**简单粗暴**的执行方案就是扫**描表中的所有记录**。判断**每一条记录是否符合**搜索条件。如果**符合**，就将其**发送到客户端**，否则就**跳过该记录**。这种**执行方案**也称为**全表扫描**。对于使用 InnoDB 存储引擎的表来说，全表扫描意味右从**聚簇索引第一个叶子节点的第一条记录**开始，沿着**记录所在的单向链表向后扫描** 直到**最后一个叶子节点的最后一条记录**(叶子节点：页，16KB；即页内最后一条)。虽然全表扫描是一种很笨的执行方案，但却是一种**万能**的执行方案，**所有的查询都可以使用这种方案**来执行。

## 扫描区间和边界条件



## 索引用于排序

## 索引用于分组

## 回表的代价

# 更好地创建和使用索引

