---
title: java内存模型
description: java内存模型
categories:
  - 学习
tags:
  - 复习
  - 复习-javaGuide
  - 复习-javaGuide-并发
date: 2022-11-21 10:57:24
updated: 2022-11-21 10:57:24
---

## 从CPU缓存模型说起

- redis是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题，**CPU缓存则是为了解决CPU处理速度和内存处理速度不对等的问题**

- 把内存看作外存的高速缓存，程序运行时把外存的数据复制到内存，由于**内存的处理速度远高于外存**，这样提高了处理速度

- 总结，**CPU Cache缓存的是内存数据**，用于解决**CPU处理速度和内存不匹配**的问题，内存缓存的是硬盘数据用于解决硬盘访问速度国漫的问题
  CPU Cache示意图：  

  ![image-20221121161418654](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221121161418654.png)
  CPU Cache通常分为三层，分别叫L1，L2，L3 Cache
  工作方式：  **先复制一份数据到CPUCache中，当CPU需要用的时候就可以从CPUCache中读取数据，运算完成后，将运算得到的数据，写回MainMemory中**，此时，会出现**内存缓存不一致的问题**，例子：执行了i++，如果两个线程同时执行，假设两个线程从CPUCach中读取的i=1，两个线程做了1++运算完之后再写回MainMemory，此时i=2 而正确结果为3

- CPU为了解决内存缓存不一致问题，可以通过制定**缓存一致协议（比如MESI协议）或其他手段**。指的是在 **CPU 高速缓存与主内存交互的时候需要遵守的原则和规范**
  ![image-20221121163447850](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221121163447850.png)
  操作系统，通过**内存模型MemoryModel**定义一系列规范来解决这个问题

## 指令重排序

- **什么是指令重排序？** 简单来说就是系统在**执行代码的时候并不一定是按照你写的代码的顺序**依次执行

- 指令重排有下面2种

  - 编译器优化重排：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。
  - 指令并行重排：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序
  - 内存系统也会有“重排序”，在JMM表现为主存和本地内存可能不一致

  即Java源代码会经历 **编译器优化重排**--->**指令并行重排**--->**内存系统重排**，最终编程操作系统可执行的**指令序列**

  极其重要★：指令重排序可以**保证串行语义一致**，但是**没有义务保证多线程间的语义也一致**，所以在多线程下指令重排可能导致一些问题

  > 编译器和处理器的指令重排序的处理方式不一样。对于**编译器**，通过**禁止特定类型的编译器重排序**的方式来禁止重排序。对于**处理器**，通过**插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）**的方式来禁止特定类型的处理器重排序。指令并行重排和内存系统重排都属于是处理器级别的指令重排序。
  >
  > 内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使**处理器写入、读取值之前**，**将主内存的值写入高速缓存，清空无效队列**，从而保障变量的可见性。

## JMM（JavaMemoryMode）

## 再看并发编程三个重要特性

## 总结

