---
title: jvm-intro
description: jvm-intro
categories:
  - 学习
tags:
  - 复习
  - 复习-javaGuide
  - 复习-javaGuide-jvm
date: 2022-12-09 08:48:22
updated: 2022-12-09 08:48:22
---

> 转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!
>
> 原文地址： https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28  

# JVM的基本介绍

- JVM，JavaVirtualMachine的缩写，虚拟出来的计算机，通过在实际的计算机上**仿真模拟**各类计算机功能实现
- JVM类似一台小电脑，运行在windows或者linux这些**真实操作系统环境下**，**直接**和操作系统交互，**与硬件不直接交互**，操作系统帮我们完成和硬件交互的工作

![img](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/d947f91e44c44c6c80222b49c2dee859-new-image19a36451-d673-486e-9c8e-3c7d8ab66929.png)

## Java文件是如何运行的

场景假设：我们写了一个HelloWorld.java，这是一个文本文件。JVM不认识文本文件，所以**需要一个编译**，让其(xxx.java)成为一个**JVM会读的二进制文件---> HelloWorld.class**

1. 类加载器
   如果JVM想要执行这个.class文件，需要将其**(这里应该指的二进制文件)**装进**类加载器**中，它就像一个搬运工一样，会把所有的.class文件全部搬进JVM里面
   ![img](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/81f1813f371c40ffa1c1f6d78bc49ed9-new-image28314ec8-066f-451e-8373-4517917d6bf7.png)

2. 方法区

   > 类加载器将.class文件搬过来，就是先丢到这一块上  

   方法区是用于**存放类似于元数据信息方面的数据**的，比如**类信息**、**常量**、**静态变量**、**编译后代码**...等

3. 堆
   堆主要放一些**存储的数据**，比如**对象实例**、**数组**...等，它和**方法区**都同属于**线程共享区域**，即它们都是**线程不安全**的

4. 栈

   线程独享  
   栈是我们**代码运行空间**，我们编写的**每一个方法**都会放到**栈**里面运行。  
   名词：**本地方法栈**或**本地方法接口**，不过我们基本不会涉及这两块内容，这**两底层使用C**进行工作，**和Java没有太大关系**

5. 程序计数器
   主要就是完成一个加载工作，类似于一个指针一样的，**指向下一行我们需要执行的代码**。和栈一样，都是**线程独享**的，就是**每一个线程都会自己对应的一块区域**而不会存在并发和多线程问题。

6. 小总结
   ![img](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/897863ee5ecb4d92b9119d065f468262-new-imagef7287f0b-c9f0-4f22-9eb4-6968bbaa5a82.png)

   1. Java文件经过编译后编程.class字节码文件
   2. 字节码文件通过类加载器被搬运到 JVM虚拟机中
   3. 虚拟机主要的5大块：**方法区、堆** 都为**线程共享**区域，有线程安全问题；**栈**和**本地方法栈**和**计数器**都是**独享**区域，不存在线程安全问题，而JVM的调优主要就是围绕**堆**、**栈**两大块进行

## 简单的代码例子

一个简单的学生类及main方法:  

```java
public class Student {
    public String name;

    public Student(String name) {
        this.name = name;
    }

    public void sayName() {
        System.out.println("student's name is : " + name);
    }
}
```

main方法：  

```java
public class App {
    public static void main(String[] args) {
        Student student = new Student("tellUrDream");
        student.sayName();
    }
}
```

★★ 执行main方法的步骤如下  

1. 编译好App.java后得到App.class后，执行APP.class，**系统会启动一个JVM进程**，从**classpath类路径中找到一个名为APP.class的二进制文件**，将**APP的类信息加载到运行时数据区的方法区**内，这个过程叫做**APP类的加载**
2. JVM找到**APP的主程序入口**，**执行main**方法
3. 这个main的第一条语句**(指令)**为 ```Student student = new Student("tellUrDream")```，就是让JVM创建一个Student对象，但是这个时候方法区是没有Student类的信息的，所以JVM马上加载Student类，**把Student类的信息放到方法区中**
4. 加载完Student类后，**JVM在堆中为一个新的Student实例分配内存**，然后**调用构造函数初始化Student实例**，这个Student实例**(对象)**持有**指向方法区中的Student类的类型信息**的引用
5. 执行```student.sayName;```时，JVM根据student的引用**找到student对象**，然后根据student对象**持有的引用**定位到**方法区中student类的类型信息的方法表**，获得**sayName()的字节码地址**。
6. 执行sayName()

其实也不用管太多，只需要知道**对象实例初始化时**，会**去方法区中找到类信息**（没有的话先加载），完成后再到**栈那里去运行方法**

# 类加载器的介绍

**类加载器**负责**加载.class**文件，.class文件的开头会有**特定的文件标识**，将**class文件字节码内容**加载到内存中，并**将这些内容**转换成**方法区**中的**运行时数据结构**，并且ClassLoader只**负责class文件的加载**，而能否运行则由**Execution Engine**来决定

## 类加载器的流程

从**类被加载到虚拟机内存**中开始，到**释放内存**总共有7个步骤：  
**加载**，**验证**，**准备**，**解析**，**初始化**，**使用**，**卸载**。  
其中**验证**，**准备**，**解析**三个部分统称为**链接**

### 加载

1. 将class文件**加载到内存**
2. 将**静态数据结构**转化成**方法区中运行的数据结构**
3. 在**堆**中生成一个代表这个类的**java.lang.Class对象**作为数据访问的入口

### 链接

1. 验证：确保加载的类**符合JVM规范和安全**，保证**被校验类的方法**在运行时不会做出**危害虚拟机**的事件，其实就是一个**安全检查**
2. 准备：为**static变量**在**方法区分配内存空间**，**设置**变量的**初始值**，例如```static int = 3 ```（注意：准备阶段只设置**类中的静态变量**（**方法区**中），**不包括实例变量（堆内存中）**，实例变量是**对象初始化时赋值的**）
3. 解析：虚拟机将**常量池内的符号引用**，替换为**直接引用**的过程（符号引用比如我现在 ```import java.util.ArrayList``` 这就算**符号引用**，**直接引用就是指针或者对象地址**，注意**引用对象一定是在内存进行**）

### 初始化

- 初始化就是**执行类构造器方法的```<clinit>()```的过程**，而且要**保证执行前父类的```<clinit>()```方法已经执行完毕**。
- 这个方法由编译器**收集(也就是编译时产生)**，**顺序执行所有类变量**(static 修饰的成员变量) **显示初始化**和静**态代码块中**语句
- 此时准备阶段时的那个static int a 由默认初始化的0**变成了显示初始化的3**。由于执行顺序缘故，**初始化阶段类变量**如果在静态代码中**又**进行更改，则会覆盖类变量的**显式初始化**，最终**值**会为静态代码块中的**赋值**

> 1. 字节码文件中初始化方法有两种，**非静态资源初始化**的<init>和**静态资源初始化**的<clinit>
> 2. 类构造器方法<clinit>() **不同于**类的构造器，这些方法都是**字节码文件中**只能给**JVM**识别的特殊方法

### 卸载

**GC将无用对象从内存中卸载**

## 类加载器的加载顺序

加载一个Class类的顺序也是有优先级的**(加载，也可以称"查找")** ，**类加载器** **从最底层开始往上**的顺序：

1. BootStrap ClassLoader： rt.jar  **(lib/rt.jar)**
2. Extension ClassLoader: 加载扩展的jar包  **(lib/ext/xxx.jar)**
3. APP ClassLoader： 指定的classpath下面的jar包   
4. Custom ClassLoader： 自定义的类加载器

## 双亲委派机制

- 当一个类收到了加载请求时，它是**不会先自己去尝试加载**的，而是**委派给父类**去完成，比如我现在要 new 一个 Person，这个 Person 是我们自定义的类，如果我们要加载它，就会**先委派 App ClassLoader** ，只有**当父类加载器都反馈自己无法完成**这个请求（也就是**父类加载器都没有找到加载所需的 Class**）时，子类加载器才会自行尝试加载。

- 好处：加载**位于 rt.jar 包中的类**时**不管是哪个加载器加载**，**最终都会委托到 BootStrap ClassLoader** 进行加载，这样保证了**使用不同的类加载器得到的都是同一个结果**。

- 其实这起了一个隔离的作用，避免自己写的代码影响**JDK的代码**

  ```java
  package java.lang;
  public class String {
      public static void main(String[] args) {
          System.out.println();
      }
  } 
  ```

  > 尝试运行当前类的 `main` 函数的时候，我们的代码肯定会报错。这是因为在加载的时候其实是找到了 rt.jar 中的`java.lang.String`，然而发现这个里面并没有 `main` 方法。

# 运行时数据区

## 本地方法栈和程序计数器

- 比如说我们现在点开Thread类的源码，会看到它的start0方法带有一个native关键字修饰，而且**不存在方法体**，这种**用native修饰的方法**就是**本地方法**，这是使用C来实现的，然后一般这些方法都会放到一个叫做**本地方法栈**的区域。
- **程序计数器**其实就是**一个指针**，它**指向了我们程序中下一句需要执行的指令**，它也是**内存区域中唯一一个不会出现OutOfMemoryError**的区域，而且**占用内存空间小到基本可以忽略不计**。这个**内存仅代表当前线程所执行的字节码的行号指示器**，字节码解析器通过**改变这个计数器的值选取下一条需要执行的字节码指令**。
  - 如果执行的是native方法，那这个指针就不工作了

## 方法区

- 主要存放**类的元数据信息**、**常量**和**静态变量**...等。
- 存储过大时，会在无法满足内存分配时报错

## 虚拟机栈和虚拟机堆

- **栈管运行**，**堆管存储**
- 虚拟机栈负责运行代码，虚拟机堆负责存储数据

### 虚拟机栈的概念

- 虚拟机栈是Java**方法执行的内存模型**
- 对**局部变量**、**动态链表**、**方法出口**、**栈的操作(入栈和出栈)**进行**存储**，且**线程独享**。
- 如果我们听到**局部变量表**，就是在说**虚拟机栈**

```java
public class Person{
    int a = 1;
    
    public void doSomething(){
        int b = 2;
    }
}
```

### 虚拟机栈存在的异常

- 如果线程请求的栈的深度，**大于虚拟机栈的最大深度**，就会报**StackOverflowError**(比如递归)
- Java虚拟机也可以**动态扩展**，但**随着扩展会不断地申请内存**，当无法申请足够内存时就会报错 **OutOfMemoryError** 

### 虚拟机栈的生命周期

- 栈**不存在垃圾回收**，只要程序运行结束，栈的空间自然释放
- 栈的**生命周期和所处的线程**一致
- **8种基本类型的变量+对象的引用变量+实例方法**，都是在栈里面分配内存

### 虚拟机栈的执行

- **栈帧**数据，在JVM中叫**栈帧**，Java中叫**方法**，它也是放在栈中
- 栈中的数据以**栈帧**的格式存在，它是一个**关于方法**和**运行期数据**的数据集

> 比如我们执行一个方法a，就会对应产生一个栈帧A1，然后A1会被压入栈中。同理方法b会有一个B1，方法c会有一个C1，等到这个线程执行完毕后，栈会先弹出C1，后B1,A1。它是一个先进后出，后进先出原则。

### 局部变量的复用

- 用于**存放方法参数**和**方法内部所定义的局部变量**

- 容量以**Slot**为最小单位，一个slot可以存放32以内的数据类型。

  > 在局部变量表里，**32位以内的类型只占用一个slot**（包括returnAddress类型），**64位的类型（long和double）占两个slot**。

- 虚拟机通过索引方式使用局部变量表，范围为 **[ 0 , 局部变量表的slot的数量 ]**。方法中的**参数**就会**按一定顺序排列**在这个局部变量表中 

- 为了节省栈帧空间，这些**slot**是可以复用的。当方法**执行位置超过了某个变量（这里意思应该是用过了这个变量）**，那么**这个变量的slot可以被其它变量复用**。当然如果需要复用，那我们的**垃圾回收自然就不会去动这些内存**

### 虚拟机堆的概念

- JVM内存会划分为**堆内存**和**非堆内存**，**堆内存**也会划分为**年轻代**和**老年代**，而**非堆内存**则为**永久代**。

- 年轻代又分为**Eden**和**Survivor**区，Survivor还分为**FromPlace**和**ToPlace**，toPlace的survivor区域是空的

- **Eden：FromPlace：ToPlace**的默认占比是8：1：1，当然这个东西也可以通过一个```-XX:+UsePSAdaptiveSurvivorSizePolicy```参数来**根据生成对象的速率动态调整**  
  （因为存活的对象相对较少）

- 堆内存中**存放的是对象**，垃圾收集就是**收集这些对象然后交给GC算法进行回收**。非堆内存其实我们已经说过了，就是**方法区**。在**1.8中已经移除永久代**，替代品是一个**元空间(MetaSpace)**，最大区别是**metaSpace是不存在于JVM**中的，它**使用的是本地内存**。并有两个参数：

  ```shell
  MetaspaceSize：初始化元空间大小，控制发生GC
  MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。
  ```

- 移除的原因  
  融合**HotSpot JVM和JRockit VM**而做出的改变，因为**JRockit是没有永久代**的，不过这也**间接性地解决了永久代的OOM**问题。

### Eden年轻代的介绍



### 如何判断一个对象需要被干掉

### 如何宣告一个对象的真正死亡

## 垃圾回收算法



## （了解）各种各样的垃圾回收器

## （了解） JVM的常用参数

# 关于JVM调优的一些方面

## 调整最大堆内存和最小堆内存

## 调整新生代和老年代的比值

## 调整Survivor区和Eden区的比值

## 设置年轻代和老年代的大小

## 小总结

## 永久区的设置

## JVM的栈参数调优

# finally