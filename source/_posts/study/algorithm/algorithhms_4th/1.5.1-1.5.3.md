---
title: "算法红皮书 1.5.1-1.5.3"
description: '案例研究：union-find 算法'
categories:
  - 学习
tags:
  - 算法红皮书(第四版)
date: 2022-04-09 08:01:47 

---

## 案例研究：union-find 算法

- 设计和分析算法的基本方法
  - 优秀的算法能解决实际问题
  - 高效的算法也可以很简单
  - 理解某个实现的性能特点是一项有趣的挑战
  - 在解决同一个问题的多种算法间选择，科学方法是一种重要工具
  - 迭代式改进能让算法效率越来越高

### 动态连通性

- 从输入中读取整数对p q，如果已知的所有整数对都不能说明p,q相连，就打印出pq
- 网络：整个程序能够判定是否需要在pq之间架设一条新的连接才能进行通信
- 变量名等价性（即指向同一个对象的多个引用）
- 数学集合：在处理一个整数对pq时，我们是在判断它们是否属于相同的集合
- 本节中，将对象称为**触点**，整数对称为**连接**，等价类称为**连通分量**或是**简称分量**
- 连通性 问题只要求我们的程序能够判别给定的整数对pq是否相连，并没有要求给两者之间的通路上的所有连接
- union-find算法的API  
  ![image-20220413001331923](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220413001331923.png)
- 数据结构和算法的设计影响到算法的效率

### 实现

```java
public class UF
{
	private int[]	id;
	/* 分量id（以触点作为索引） */
	private int	count;
	/* 分量数量 */
	public UF( int N )
		{
		/* 初始化分量id数组 */
		count	= N;
		id	= new int[N];
		for ( int i = 0; i < N; i++ )
					id[i] = i;
	}
	public int count()
		{
		return(count);
	}
	public Boolean connected( int p, int q )
		{
		return(find( p ) == find( q ) );
	}
	public int find( int p )
		public void union( int p, int q )
	/* 请见1.5.2.1节用例（quick-find）、1.5.2.3节用例（quick-union）和算法1.5（加权quick-union） */
	public static void main( String[] args )
		{
		/* 解决由StdIn得到的动态连通性问题 */
		int	N	= StdIn.readint();
		/* 读取触点数量 */
		UF	uf	= new UF( N );
		/* 初始化N个分量 */
		while ( !StdIn.isEmpty() )
				{
			int	p	= StdIn.readint();
			int	q	= StdIn.readint();
			/* 读取整数对 */
			if ( uf.connected( p, q ) )
							continue;
			/* 如果已经连通则忽略 */
			uf.union( p, q );
			/* 归并分量 */
			StdOut.println( p + " " + q );
			/* 打印连接 */
		}
		StdOut.println( uf.count() + "components" );
	}
}
```

union-find的成本模型：union-find API的各种算法，统计的是**数组的访问次数**，不论读写  

- 以下有三种实现

  - 且仅当id[p] 等于id[q] 时p 和q 是连通的

    ```java
    public int find(int p)
    {
    	return id[p];
    }
    public void union(int p, int q)
    {
    	// 将p和q归并到相同的分量中
    	int pID = find(p);
    	int qID = find(q);
    	// 如果p和q已经在相同的分量之中则不需要采取任何行动
    	if (pID == qID) return;
    	// 将p的分量重命名为q的名称
    	for (int i = 0; i < id.length; i++)
    	if (id[i] == pID) id[i] = qID;
    	count--;
    }
    ```

  - 

#### quick-find算法

#### quick-find算法的分析

#### quick-find算法

#### 森林的标识

#### quick-union算法的分析

#### 加权quick-union算法

#### 加权quick-union算法的分析

#### 均摊成本的图像

### 展望
