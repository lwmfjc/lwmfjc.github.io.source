---
title: 07B+数索引的使用
description: 07B+数索引的使用
tags:
  - MySQL是怎样运行的
categories:
  - 学习
date: 2023-04-24 14:32:22
updated: 2023-04-24 14:32:22
---

> 学习《MySQL是怎样运行的》，感谢作者！



# InnoDB存储引擎的B+树索引：结论

- **每个索引**对应一颗B+树。B+树有好多层，**最下边一层**是**叶子节点**，其余是**内节点**。所有**用户记录**都存在B+树的**叶子节点**，所有**目录项记录**都存在内节点
- InnoDB 存储引擎会**自动为主键建立聚簇索引**(如果**没有显式指定主键**或者**没有声明不允许存储NULL的UNIQUE 键**，它会自动添加主键) ， **聚簇索引**的**叶子节点**包含**完整的用户记录**
-  我们可以为感兴趣的列建立**二级索引**，二级索引的叶子节点包含的用户记录由**索引列**
  **和主键**组成。如果想通过二级索引查找完整的用户记录，需要执行**回表**操作， 也就是在通过二级索引**找到主键值之后**，再到**聚簇索引**中查找完整的用户记录
- B+ 树中的**每层节点**都按照**索引列的值从小到大的顺序排序**组成了**双向链表**，而且每个**页内的记录**(无论是**用户记录**还是**目录项记录**)都按照索引列的值从小到大的顺序形成了一个单向链表。如果是联合索引， 则**页面**和**记录** **先**按照索引列中前面的列的值排序：**如果该列的值相同**，**再按照索引列中后面的列的值排序**。比如， 我们对列c2 和c3建立了联合索引 **idx_c2_c3(c2， c3)**，那么该索引中的页面和记录就**先按照c2 列**的值进行排序；**如果c2 列的值相同**， **再按照c3** 列的值排序
- 通过索引查找记录时，是**从B+ 树的根节点开始一层一层向下搜索的**。由于每个页面(无论是**内节点页面**还是**叶子节点页面**〉中的记录都划分成了**若干个组**， 每个组中**索引列值最大的记录**在**页内的偏移量**会被当作**槽**依次存放在**页目录中**(当然， 规定Supremum 记录比任何用户记录都大) ，因此可以在**页目录中通过二分法**快速定位到**索引列等于某个值的记录**  

>  如果大家在阅读上述结论时哪怕有点疑惑， 那么下面的内容就不适合你，请回过头去反复阅读前面的章节

# B+树索引示意图的简化

```shell
#创建新表
mysql> CREATE TABLE single_table(
      id INT NOT NULL AUTO_INCREMENT,
      key1 VARCHAR(100),
      key2 INT,
      key3 VARCHAR(100),
      key_part1 VARCHAR(100),
      key_part2 VARCHAR(100),
      key_part3 VARCHAR(100),
      common_field VARCHAR(100),
      PRIMARY KEY (id),
      KEY idx_key1(key1),
      UNIQUE KEY uk_key2(key2),
      KEY idx_key3(key3),
      KEY idx_key_part(key_part1,key_part2,key_part3)
      ) Engine=InnoDB CHARSET = utf8;
```

如上，建立了**1个聚簇索引**，**4个二级索引**  

- 为id列建立的聚簇索引
- 为key1列建立的idx_key1二级索引
- 为key2列建立的uk_key2二级索引，而且该索引是**唯一二级索引**
- 为key3列建立的idx_key3二级索引
- 为key_part1、key_part2、key_part3列建立的**idx_key_part二级索引**，是一个**联合索引**

接下来为这个表**插入10,000行记录**  
**除了id，其余的列取随机值**：该表后面会频繁用到  

> 需要用程序写，这里暂时跳过（不会...，书上也没写）

回顾：B+树包括**内节点**和**叶子节点**，以及**各个节点中的记录**。B+树其实是一个**矮矮的大胖子**，能够**利用B+树快速地定位记录**，下面简化一下B+树的示意图：  

- 忽略**页结构**，直接把所有**叶子节点中的记录**放一起
- **为了方便**，把**聚簇索引叶子节点**的记录称为**聚簇索引记录**，把**二级索引叶子节点**称为**二级索引记录**

> **回顾一下**：  
>
> 核心要点：把**下一层**每一页的**最小值**，放到**上一级**的**目录项记录**，以**key值+页号**这样的组合存在
>
> ![image-20230423142254862](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423142254862.png)

**精简**：  

![image-20230424224802689](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230424224802689.png)

如上，**聚簇索引**记录是按照**主键值**由小到大的**顺序排列**的    
如下图，通过B+树**定位到id值为1438**的记录  
![image-20230424231409778](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230424231409778.png)

**二级索引idx_key1**对应的B+树中**保留了叶子结点的记录**。以key1排序，如果key1相同，则按照id列排序  
![image-20230424231612980](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230424231612980.png)

> **为了方便**，把**聚簇索引叶子节点**的记录称为**聚簇索引记录**，把**二级索引叶子节点**称为**二级索引记录**

如果要查找**key1值**等于**某个值**的**二级索引**记录，通过**idx_key1**对应的B+树，可以很容易定位到第一条**key1列的值**等于**某个值**的二级索引记录，然后**沿着单向链表**向后扫描即可。  
![image-20230424234609722](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230424234609722.png)

# 索引的代价

## 空间上的代价

每建立**一个索引**，都要为他建立**一颗**B+树。每**一颗B+树**的每一个节点都是**一个数据页**（一个数据页默认占用16KB），而一颗**很大**的B+树由许多数据页组成，这将占用很大的片存储空间

## 时间上的代价

- 每当对表中数据进行**增上改查**时，都要**修改各个B+树**索引
- 执行**查询语句**前，都要生成一个**执行计划**。一般情况下，**一条查询语句**在执行过程中**最多用到一个二级索引**（有例外，10章），在生成执行计划时需要**计算**使用**不同索引**执行查询时所需要的**成本**，最后选取**成本最低**的那个索引执行查询（12章：**如何计算查询成本**）==> 索引太多导致**分析时间过长**  

## 总结

索引越多，存储空间越多，**增删改**记录或者**生成执行计划时**性能越差  
为了建立**又好又少**的索引，得先了解**索引**在**查询执行期间**到底是如何发挥作用的  

# 应用B+树索引

对于某个查询来说，最**简单粗暴**的执行方案就是扫**描表中的所有记录**。判断**每一条记录是否符合**搜索条件。如果**符合**，就将其**发送到客户端**，否则就**跳过该记录**。这种**执行方案**也称为**全表扫描**。

> 对于使用 I**nnoDB 存储引擎**的表来说，全表扫描意味着从**聚簇索引第一个叶子节点的第一条记录**开始，沿着**记录所在的单向链表向后扫描** 直到**最后一个叶子节点的最后一条记录**(叶子节点：页，16KB；即页内最后一条)。虽然全表扫描是一种很笨的执行方案，但却是一种**万能**的执行方案，**所有的查询都可以使用这种方案**来执行。

## 扫描区间和边界条件

可以利用**B+树**查找**索引值**等于某个值的记录=>**减少**需要扫描的记录**数量**。由于*B+树叶子节点中的记录是按照**索引列值由小到大**的顺序排序的，所以**只**扫描**某个区间**或者**某些区间**中的记录也可以明显**减少**需要扫描的记录数量。  

### 简单例子

#### 例子1（聚簇索引）

例子：```SELECT * FROM single_table WHERE id>=2 AND id <=100```  
这个语句其实是要找id值在**[2,100]**区间中的所有**聚簇索引**记录。  

- 可以通过**聚簇索引**对应的B+树快速地定位到**id值为2**的那条聚簇索引记录，然后沿着记录所在的**单向链表**向后扫描，直到某条聚簇索引记录的**id值不在[2,100]区间中**为止（即id不再符合**id<=100**条件）  
- 与扫描**全部**的聚簇索引记录相比，扫描id 值在**[2,100]** 区间中的记录已经很大程度地减少了需要扫描的记录数量， 所**以提升了查询效率**。简便起见，我们把这个例子中**待扫描记录的id 值所在的区间**称为**扫描区间**，把**形成**这个扫描区间的**搜索条件**(也就是**id >= 2AND > id <=**
  **100** ) 称为**形成这个扫描区间的边界条件**.

对于**全表扫描**来说，相当于扫描id在**(-∞,+∞)** 区间中的记录，也就是说**全表扫描**对应的**扫描区间**是**(-∞,+∞)**  

#### 例子2（二级索引）

```mysql
SELECT * FROM single_table WHERE key2 IN (1438,6328 ) OR (key2 >=38 AND key2 <=79)
```

可以直接使用**全表扫描**的方式执行该查询。  
但是我们发现该查询的**搜索条件**涉及**key2列**，而我们又正好为**key2列**建立了**uk_key2索引**。如果使用**uk_key2索引**执行这个查询，则相当于从下面的3个**扫描区间**中**获取二级索引记录**：  

- **[1438,1438]** ：对应的**边界条件**就是key2 IN (1438)
- **[6328,6328]**：对应的**边界条件**就是key2 IN (6328)
- **[38,79]**：对应的**边界条件**就是key2 >= 38 AND key2 <= 79

这些**扫描区间**对应到**数轴**上时，如图  
![image-20230427224703784](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230427224703784.png)

方便起见，我们把像[1438,1438]、[6328, 6328] 这样**只包含一个值**的**扫描区间**称为**单点扫描区间**， 把[38， 79] 这样**包含多个值**的**扫描区间**称为**范围扫描区间**。另外，由于我们的查询列表是 * ，也就是**需要读取完整的用户记录**，所以从上述扫描区间中**每获取一条二级索引记录**， 就需要根据**该二级索引记录id列的值执行回表**操作，也就是**到聚簇索引**中找到相应的聚**簇索引记录**。  

> - 其实我们不仅仅可以使用uk_key2 执行上述查询， 还可以使用**idx_key1**、**idx_key3** 、**idx_key_part** 执行上述查询。以**idx_key_1** 为例，很显然**无法**通过搜索条件**形成合适的扫描区间**来**减少需要扫描的idx_key1 二级索引记录**的数量，只能扫描idx_keyl 的**全部**二级索引记录。针对获取到的**每一条二级索引**记录，都需要**执行回表操作**来获取**完整**的用户记录.。我们也可以说，使用**idx_key1 执行查询**时对应的扫描区间就是**(-∞,+∞)**
> - 这样虽然行得通，但我们图啥呢，最简单粗暴的**全表扫描**方式已经需要**扫描全部的聚簇索引**记录， 这里**除了需要访问全部的聚簇索引**记录，还要扫描**全部的idx_key1二级索**
>   **引记录**，这不是费力不讨好么。可见， 在这个过程中并**没有减少**需要扫描的记录数量，效
>   率反而**比全表扫描差**。所以如果想**使用某个索引来执行**查询，但是又**无法**通过搜索条件
>   形成**合适的扫描区间**来减少需要扫描的记录数量时， 则**不考虑使用这个索引**执行查询

#### 例3 不是索引的搜索条件都可以成为边界条件

```mysql
SELECT * FROM single_table WHERE key1 < 'a' AND key3 > 'z' AND common_field = 'abc'
```

- 如果使用**idx_key1** 执行查询，那么相应的**扫描区间**就是(-∞,'a')，形成该**扫描区间**的**边界条件**就是key1 < 'a'。而 key3 > 'z' AND common_field = 'abc'就是普通的搜索条件，这些普通的搜索条件需要在获取到**idx_key1**的**二级索引记录**后，再执行**回表操作**，在获取到**完整的用户记录**后才能去判断它们是否成立
- 而如果使用idx_key3 执行查询，那么相应的**扫描区间**就是'z'，形成该**扫描区间**的**边界条件**就是key3>'z'。而key1<'a' AND common_field='abc'就是**普通**的搜索条件，这些普通的搜索条件需要在获取到**idx_key3**的二级索引记录后，再**执行回表操作**，在获取到完整的**用户记录**后才能去判断它们是否成立

#### 总结

在使用某个索引执行查询时，**关键**的问题就是通过**搜索条件**找出合适的扫描区间，然后再到对应的**B+ 树**中**扫描索引列值在这些扫描区间**的记录。对于每个扫描区间来说，仅需要**通过B+ 树**定位到该**扫描区间中的第一条记录**，然后就可以**沿着记录所在的单向链表向后扫描**，**直到某条记录不符合形成该扫描区间的边界条件**为止。其实对于B+ 树索引来说，只要**索引列**和**常数**使用**=、<=>、lN、NOT IN、IS NULL、IS NOT NULL、> 、<、=、<=、BETWEEN 、! = (也可以写成< >)或者LIKE 操作符**连接起来，就可以产生所谓的**扫描区间**。不过有下面几点需要注意：  

- **lN**操作符的语义与**若干个等值匹配操作符( =)之间用OR 连接**起来的语义是一样的，都会产生**多个单点扫描区间**。比如下面这两个语句的语义效果是一样的：  

  ```mysql
  SELECT * FROM single_table WHERE key2 IN (1438,6328);
  #与上面的语义效果一样
  SELECT * FROM single_table WHERE key2 = 1438 OR key2 = 6328
  ```

- != 产生的扫描区间比较有趣，如：    

  ```mysql
  SELECT * FROM single_table key1 != 'a';
  ```

  此时idx_key1执行查询时对应的**扫描区间**就是(-∞,'a') 和('a',+∞)

- LIKE操作符比较特殊，只有在**匹配完整的字符串**或者**匹配字符串前缀**时才产生合适的扫描区间  
  比较**字符串**的大小，其实就相当于**一次比较每个字符的大小**。**字符串的比较过程**如下所示：  

  1. 先比较字符串的**第一个**字符：第一个字符小的那个字符串就比较小
  2. 如果两个字符串的**第一个字符相同**，再比较**第二个字符**；第二个字符比较小的那个字符串就比较小
  3. 如果两个字符串的**前两个字符**都相同，那么就接着比较**第三个字符**：依此类推  

  对于**某个索引列**来说，**字符串前缀相同的记录**在**由记录组成的单向链表中**肯定是**相邻的**。  

  > 比如我们有一个搜索条件是key1 LIKE 'a%'。 对于二级索引 **idx_key1** 来说，**所有字符串前缀为'a'的二级索引记录肯定是相邻的**。这也就意味着我们只要定位 **key1** 值的字符串**前缀为'a'** 的**第一条**记录，就可以沿着记录所在的单向链表向后扫描， **直到**某条二级索引记录的**字符串前缀不为'a'** 为止，如图7-7 所示。很显然 **key1 LIKE 'a%'** 形成的扫描区间相当于**['a','b')**    
  > ![image-20230428211918975](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230428211918975.png)

### 稍复杂例子

日常工作中，一个查询语句中的**WHERE子句**可能有**多个小的搜索条件**，这些搜索条件使用**AND 或者OR** 操作符连接起来。虽然大家都知道这两个操作符的作用，但这里还是要再强调一遍： 

- **cond1 AND cond**2 只有当**cond1和cond2都为TRUE** 时，整个表达式才为TRUE
- **cond1 OR cond2** ， 只要**cond1 或者cond2** 中**有一个为TRUE**， 整个表达式就为TRUE  

在我们执行一个查询语句时，首先需要找出**所有可用的索引**以及**使用它们时对应的扫描区间**。下面我们来看一下怎么从包含**若干个AND 或OR** 的复杂搜索条件中**提取出正确的扫描区间**：  

#### 所有搜索条件都可以生成合适的扫描区间的情况

##### AND结合

```mysql
SELECT * FROM single_table WHERE key2 > 100 AND key2 > 200;
```

其中，**每个小的搜索条件**都可以生成一个合适的扫描区间来**减少需要扫描的记录数量**，最终的扫描区间就是对**这两个小的搜索条件**形成的**扫描区间取交集**后的结果，取交集的过程：  
![image-20230428214210971](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230428214210971.png)

上面查询语句使用**uk_key2**索引执行查询时对应的扫描区间就是**(200,+∞)**，形成该扫描区间的**边界条件**就是**key2 > 200**  

##### OR结合

使用**OR**操作符将**多个搜索条件连接在一起**：  

```mysql
SELECT * FROM single_table WHERE key2 > 100 OR key2 > 200
```

OR意味着需要取**各个扫描区间的并集**，取并集的过程如图所示：  
![image-20230428214539243](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230428214539243.png)

即，上面的查询语句在使用**uk_key2**索引执行查询时，对应的扫描区间就是**(100,+∞)，**形成扫描区间的**边界条件**就是**key2 > 100**

#### 有的搜索条件不能生成合适的扫描区间的情况



#### 从复杂的搜索条件中找出扫描区间

#### 使用联合索引执行查询时对应的扫描区间



## 索引用于排序

## 索引用于分组

## 回表的代价

# 更好地创建和使用索引

