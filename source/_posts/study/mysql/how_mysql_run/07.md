---
title: 07B+数索引的使用
description: 07B+数索引的使用
tags:
  - MySQL是怎样运行的
categories:
  - 学习
date: 2023-04-24 14:32:22
updated: 2023-04-24 14:32:22
---

> 学习《MySQL是怎样运行的》，感谢作者！



# InnoDB存储引擎的B+树索引：结论

- **每个索引**对应一颗B+树。B+树有好多层，**最下边一层**是**叶子节点**，其余是**内节点**。所有**用户记录**都存在B+树的**叶子节点**，所有**目录项记录**都存在内节点
- InnoDB 存储引擎会**自动为主键建立聚簇索引**(如果**没有显式指定主键**或者**没有声明不允许存储NULL的UNIQUE 键**，它会自动添加主键) ， **聚簇索引**的**叶子节点**包含**完整的用户记录**
-  我们可以为感兴趣的列建立**二级索引**，二级索引的叶子节点包含的用户记录由**索引列**
  **和主键**组成。如果想通过二级索引查找完整的用户记录，需要执行**回表**操作， 也就是在通过二级索引**找到主键值之后**，再到**聚簇索引**中查找完整的用户记录
- B+ 树中的**每层节点**都按照**索引列的值从小到大的顺序排序**组成了**双向链表**，而且每个**页内的记录**(无论是**用户记录**还是**目录项记录**)都按照索引列的值从小到大的顺序形成了一个单向链表。如果是联合索引， 则**页面**和**记录** **先**按照索引列中前面的列的值排序：**如果该列的值相同**，**再按照索引列中后面的列的值排序**。比如， 我们对列c2 和c3建立了联合索引 **idx_c2_c3(c2， c3)**，那么该索引中的页面和记录就**先按照c2 列**的值进行排序；**如果c2 列的值相同**， **再按照c3** 列的值排序
- 通过索引查找记录时，是**从B+ 树的根节点开始一层一层向下搜索的**。由于每个页面(无论是**内节点页面**还是**叶子节点页面**〉中的记录都划分成了**若干个组**， 每个组中**索引列值最大的记录**在**页内的偏移量**会被当作**槽**依次存放在**页目录中**(当然， 规定Supremum 记录比任何用户记录都大) ，因此可以在**页目录中通过二分法**快速定位到**索引列等于某个值的记录**  

>  如果大家在阅读上述结论时哪怕有点疑惑， 那么下面的内容就不适合你，请回过头去反复阅读前面的章节

# B+树索引示意图的简化

```shell
#创建新表
mysql> CREATE TABLE single_table(
      id INT NOT NULL AUTO_INCREMENT,
      key1 VARCHAR(100),
      key2 INT,
      key3 VARCHAR(100),
      key_part1 VARCHAR(100),
      key_part2 VARCHAR(100),
      key_part3 VARCHAR(100),
      common_field VARCHAR(100),
      PRIMARY KEY (id),
      KEY idx_key1(key1),
      UNIQUE KEY uk_key2(key2),
      KEY idx_key3(key3),
      KEY idx_key_part(key_part1,key_part2,key_part3)
      ) Engine=InnoDB CHARSET = utf8;
```

如上，建立了**1个聚簇索引**，**4个二级索引**  

- 为id列建立的聚簇索引
- 为key1列建立的idx_key1二级索引
- 为key2列建立的uk_key2二级索引，而且该索引是**唯一二级索引**
- 为key3列建立的idx_key3二级索引
- 为key_part1、key_part2、key_part3列建立的**idx_key_part二级索引**，是一个**联合索引**

接下来为这个表**插入10,000行记录**  
**除了id，其余的列取随机值**：该表后面会频繁用到  

> 需要用程序写，这里暂时跳过（不会...，书上也没写）

回顾：B+树包括**内节点**和**叶子节点**，以及**各个节点中的记录**。B+树其实是一个**矮矮的大胖子**，能够**利用B+树快速地定位记录**，下面简化一下B+树的示意图：  

- 忽略**页结构**，直接把所有**叶子节点中的记录**放一起
- **为了方便**，把**聚簇索引叶子节点**的记录称为**聚簇索引记录**，把**二级索引叶子节点**称为**二级索引记录**

> **回顾一下**：  
>
> 核心要点：把**下一层**每一页的**最小值**，放到**上一级**的**目录项记录**，以**key值+页号**这样的组合存在
>
> ![image-20230423142254862](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423142254862.png)

**精简**：  

![image-20230424224802689](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230424224802689.png)

如上，**聚簇索引**记录是按照**主键值**由小到大的**顺序排列**的    
如下图，通过B+树**定位到id值为1438**的记录  
![image-20230424231409778](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230424231409778.png)

**二级索引idx_key1**对应的B+树中**保留了叶子结点的记录**。以key1排序，如果key1相同，则按照id列排序  
![image-20230424231612980](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230424231612980.png)

> **为了方便**，把**聚簇索引叶子节点**的记录称为**聚簇索引记录**，把**二级索引叶子节点**称为**二级索引记录**

如果要查找**key1值**等于**某个值**的**二级索引**记录，通过**idx_key1**对应的B+树，可以很容易定位到第一条**key1列的值**等于**某个值**的二级索引记录，然后**沿着单向链表**向后扫描即可。  
![image-20230424234609722](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230424234609722.png)

# 索引的代价

## 空间上的代价

每建立**一个索引**，都要为他建立**一颗**B+树。每**一颗B+树**的每一个节点都是**一个数据页**（一个数据页默认占用16KB），而一颗**很大**的B+树由许多数据页组成，这将占用很大的片存储空间

## 时间上的代价

- 每当对表中数据进行**增上改查**时，都要**修改各个B+树**索引
- 执行**查询语句**前，都要生成一个**执行计划**。一般情况下，**一条查询语句**在执行过程中**最多用到一个二级索引**（有例外，10章），在生成执行计划时需要**计算**使用**不同索引**执行查询时所需要的**成本**，最后选取**成本最低**的那个索引执行查询（12章：**如何计算查询成本**）==> 索引太多导致**分析时间过长**  

## 总结

索引越多，存储空间越多，**增删改**记录或者**生成执行计划时**性能越差  
为了建立**又好又少**的索引，得先了解**索引**在**查询执行期间**到底是如何发挥作用的  

# 应用B+树索引

对于某个查询来说，最**简单粗暴**的执行方案就是扫**描表中的所有记录**。判断**每一条记录是否符合**搜索条件。如果**符合**，就将其**发送到客户端**，否则就**跳过该记录**。这种**执行方案**也称为**全表扫描**。

> 对于使用 I**nnoDB 存储引擎**的表来说，全表扫描意味着从**聚簇索引第一个叶子节点的第一条记录**开始，沿着**记录所在的单向链表向后扫描** 直到**最后一个叶子节点的最后一条记录**(叶子节点：页，16KB；即页内最后一条)。虽然全表扫描是一种很笨的执行方案，但却是一种**万能**的执行方案，**所有的查询都可以使用这种方案**来执行。

## 扫描区间和边界条件

可以利用**B+树**查找**索引值**等于某个值的记录=>**减少**需要扫描的记录**数量**。由于*B+树叶子节点中的记录是按照**索引列值由小到大**的顺序排序的，所以**只**扫描**某个区间**或者**某些区间**中的记录也可以明显**减少**需要扫描的记录数量。  

### 例子1（聚簇索引）

例子：```SELECT * FROM single_table WHERE id>=2 AND id <=100```  
这个语句其实是要找id值在**[2,100]**区间中的所有**聚簇索引**记录。  

- 可以通过**聚簇索引**对应的B+树快速地定位到**id值为2**的那条聚簇索引记录，然后沿着记录所在的**单向链表**向后扫描，直到某条聚簇索引记录的**id值不在[2,100]区间中**为止（即id不再符合**id<=100**条件）  
- 与扫描**全部**的聚簇索引记录相比，扫描id 值在**[2,100]** 区间中的记录已经很大程度地减少了需要扫描的记录数量， 所**以提升了查询效率**。简便起见，我们把这个例子中**待扫描记录的id 值所在的区间**称为**扫描区间**，把**形成**这个扫描区间的**搜索条件**(也就是**id >= 2AND > id <=**
  **100** ) 称为**形成这个扫描区间的边界条件**.

对于**全表扫描**来说，相当于扫描id在**(-∞,+∞)** 区间中的记录，也就是说**全表扫描**对应的**扫描区间**是**(-∞,+∞)**  

### 例子2（二级索引）

```mysql
SELECT * FROM single_table WHERE key2 IN (1438,6328 ) OR (key2 >=38 AND key2 <=79)
```

可以直接使用**全表扫描**的方式执行该查询。  
但是我们发现该查询的**搜索条件**涉及**key2列**，而我们又正好为**key2列**建立了**uk_key2索引**。如果使用**uk_key2索引**执行这个查询，则相当于从下面的3个**扫描区间**中**获取二级索引记录**：  

- **[1438,1438]** ：对应的**边界条件**就是key2 IN (1438)
- **[6328,6328]**：对应的**边界条件**就是key2 IN (6328)
- **[38,79]**：对应的**边界条件**就是key2 >= 38 AND key2 <= 79

这些**扫描区间**对应到**数轴**上时，如图  
![image-20230427224703784](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230427224703784.png)

方便起见，我们把像[1438,1438]、[6328, 6328] 这样**只包含一个值**的**扫描区间**称为**单点扫描区间**， 把[38， 79] 这样**包含多个值**的**扫描区间**称为**范围扫描区间**。另外，由于我们的查询列表是 * ，也就是**需要读取完整的用户记录**，所以从上述扫描区间中**每获取一条二级索引记录**， 就需要根据**该二级索引记录id列的值执行回表**操作，也就是**到聚簇索引**中找到相应的聚**簇索引记录**。  

> - 其实我们不仅仅可以使用uk_key2 执行上述查询， 还可以使用**idx_key1**、**idx_key3** 、**idx_key_part** 执行上述查询。以**idx_key_1** 为例，很显然**无法**通过搜索条件**形成合适的扫描区间**来**减少需要扫描的idx_key1 二级索引记录**的数量，只能扫描idx_keyl 的**全部**二级索引记录。针对获取到的**每一条二级索引**记录，都需要**执行回表操作**来获取**完整**的用户记录.。我们也可以说，使用**idx_key1 执行查询**时对应的扫描区间就是**(-∞,+∞)**
> - 这样虽然行得通，但我们图啥呢，最简单粗暴的**全表扫描**方式已经需要**扫描全部的聚簇索引**记录， 这里**除了需要访问全部的聚簇索引**记录，还要扫描**全部的idx_key1二级索**
>   **引记录**，这不是费力不讨好么。可见， 在这个过程中并**没有减少**需要扫描的记录数量，效
>   率反而**比全表扫描差**。所以如果想**使用某个索引来执行**查询，但是又**无法**通过搜索条件
>   形成**合适的扫描区间**来减少需要扫描的记录数量时， 则**不考虑使用这个索引**执行查询

### 例3 不是索引的搜索条件都可以称为边界条件

```mysql
SELECT * FROM single_table WHERE key1 < 'a' AND key3 > 'z' AND common_field = 'abc'
```



## 索引用于排序

## 索引用于分组

## 回表的代价

# 更好地创建和使用索引

