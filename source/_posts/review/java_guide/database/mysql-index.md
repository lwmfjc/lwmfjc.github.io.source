---
title: 索引
description: 索引
categories:
  - 学习
tags:
  - 复习
  - 复习-javaGuide
  - 复习-javaGuide-database
date: 2023-01-10 22:09:25
updated: 2023-01-11 09:09:25
---

> 转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!

# 索引介绍

- 索引是一种用于**快速查询**和**检索数据**的数据结构，其本质可以看成是一种**排序好**的数据结构

  > 索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了

- 索引底层数据结构存在很多种类型，常见的索引结构有：**B树**，**B+树**和**Hash**、**红黑树**。在MySQL中，无论是Innodb还是MyIsam，都使用了B+树作为索引结构

# 索引的优缺点

**优点：**

- 使用索引可以大大**加快** 数据的检索速度（大大**减少检索的数据量**）, 这也是创建索引的最主要的原因。
- 通过创建**唯一性索引**，可以保证数据库表中**每一行数据的唯一性**。

**缺点：**

- **创建索引**和**维护索引**需要**耗费许多**时间。当对表中的数据进行**增删改**的时候，如果数据有索引，那么**索引也需要动态的修改**，会**降低 SQL 执行效率**。
- 索引需要使用**物理文件存储**，也会**耗费一定空间**

**索引一定会提高查询性能吗**

- 多数情况下，**索引查询**都是比**全表扫描**要快的。但是如果数据库的**数据量不大**，那么使用**索引也不一定能够带来很大提升**

# 索引的底层数据结构

## Hash表

- 哈希表是键值对的集合，通过**键（key）**即可**快速取出对应的值（value）**，因此哈希表可以**快速检索数据（接近O(1))**

- 为何能够通过key快速取出value呢？原因在于**哈希算法（也叫散列算法）**。通过哈希算法，我们可以**快速找到key对应的index**，找到了index也就找到了对应的value

  ```java
  hash = hashfunc(key)
  index = hash % array_size
  ```

  注意，图中keys是**字符串**，**不是什么莫名其妙的人**
  ![image-20230111105843993](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230111105843993.png)

- 哈希算法有个 **Hash 冲突** 问题，也就是说**多个不同的 key 最后得到的 index 相同**。通常情况下，我们常用的解决办法是 **链地址法**。链地址法就是**将哈希冲突数据存放在链表中**。就比如 JDK1.8 之前 `HashMap` 就是通过**链地址法来解决哈希冲突**的。不过，JDK1.8 以后`HashMap`**为了减少链表过长**的时候搜索时间过长引入了**红黑树**。

- 为了减**少 Hash 冲突**的发生，一个**好的哈希函数**应该**“均匀地”将数据分布**在整个可能的哈希值集合中  

- 由于**Hash索引**不支持**顺序**和**范围查询**，假如要对表中的数据进行**排序**或者**进行范围查询**，那**Hash索引**就不行了，并且，**每次IO**只能取一个

  > 例如：  ```SELECT * FROM tb1 WHERE id < 500 ; ```
  >
  > - 这种范围查询中，B+树 优势非常大 直接遍历比500小的叶子节点即可
  > - 如果使用Hash索引，由于**Hash索引**是根据hash算法来定位的，难不成把1 ~499 （小于500）的数据都进行一次hash计算来定位吗？这就是Hash最大的缺点

## B树& B+ 树

- B树也称B-树，全称为**多路平衡查找树**，B+树是**B树的一种变体**

- B树和B+树中的B是Balanced（平衡）的意思

- 目前**大部分数据库**以及**文件系统**都采用B-Tree或者其变种**B+Tree**作为索引结构

- B树&B+树两者有何异同呢

  1. B树的所有结点**既存放键（key）**也存放**数据（data）**，而B+树**只有叶子结点**存放key和data，其他**内节点**只存放key
  2. B树的叶子节点都是独立的；B+树的**叶子节点有一条引用链指向与它相邻的叶子节点**
  3. B树的检索的过程相当于**对范围内的每个结点的关键字做二分查找**，可能还没有到达叶子节点，检索就结束了。而**B+树**的检索效率比较稳定，任何查找都是从根节点到叶子节点的过程，叶子结点的顺序检索很明显
  4. 如图
     ![image-20230111144258302](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230111144258302.png)

- 在MySQL中，**MyISAM引擎**和**InnoDB引擎**都是使用B+Tree作为索引结构，但是，两者的实现方式有点不太一样

  > 1. MyISAM 引擎中，**B+Tree 叶节点**的 data 域存放的是**数据记录的地址**。在索引检索的时候，首先**按照 B+Tree 搜索算法**搜索索引，如果指定的 Key 存在，则**取出其 data 域的值**，然后**以 data 域的值为地址读取相应的数据记录**。这被称为“**非聚簇索引（非聚集索引）**”。
  > 2. InnoDB 引擎中，其**数据文件本身就是索引文件**。 **MyISAM** 的 索引文件和数据文件是分离的，而**InnoDB引擎**中其表数据文件本身就是按 B+Tree 组织的一个索引结构，**树的叶节点 data 域保存了完整的数据记录**。这个**索引的 key 是数据表的主键（而非地址）**，因此 InnoDB 表数据文件本身就是主索引。这被称为“**聚簇索引（聚集索引）**”，而其余的索引都作为 **辅助索引** ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在**根据主索引搜索时，直接找到 key 所在的节点即可取出数据**；在**根据辅助索引查找时**，则**需要先取出主键的值，再走一遍主索引**。
  > 3. 在设计表的时候，**不建议使用过长的字段作为主键**，也**不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂**。  
  >    原因：
  >    - InnoDB的辅助索引data域存储相应记录主键的值而不是地址。所以不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大 **(不建议使用过长的字段作为主键)**
  >    - InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效。**(不建议使用非单调的字段作为主键)**

# 索引类型

## 主键索引（Primary Key）

- 数据**表的主键列**，使用的就是**主键索引**
- 一张数据表只能有**一个主键**，并且主键不能为null，不能重复
- 在 MySQL 的 InnoDB 的表中，当**没有显示的指定表的主键时**，InnoDB 会自动先检查表中**是否有唯一索引**且**不允许存在 null 值**的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键
- 如图
  ![image-20230111155549265](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230111155549265.png)

## 二级索引（辅助索引）

- 二级索引又称为辅助索引，是因为**二级索引的叶子结点存储的数据是主键**。也就是说，通过二级索引，可以定位**主键**的位置（**还有值**）
- 唯一索引、普通索引、前缀索引等索引都属于二级索引
  1. **唯一索引 Unique Key**：是一种约束，该索引的属性列**不能出现重复的数据**，但是**允许数据为NULL**，一张表允许创建**多个唯一索引**。建立唯一索引的目的多是为了**该属性列的数据的唯一性**，而不是为了查询效率
  2. **普通索引 Index**：

# 聚簇索引与非聚簇索引

## 聚簇索引（聚集索引）

## 非聚簇索引（非聚集索引）

# 覆盖索引和联合索引

## 覆盖索引

## 联合索引

## 最左前缀匹配原则

# 索引下推

# 争取使用索引的一些建议

## 选择合适的字段创建索引

## 被频繁更新的字段应该慎重建索引

## 尽可能地考虑建立联合索引而不是单列索引