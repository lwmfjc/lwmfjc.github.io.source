---
title: InnoDB数据页结构
description: InnoDB数据页结构
tags:
  - MySQL是怎样运行的
categories:
  - 学习
date: 2023-04-21 10:35:29
updated: 2023-04-21 10:35:29
---

> 学习《MySQL是怎样运行的》，感谢作者！

# 不同类型的页简介

页是**InnoDB管理存储空间**的基本单位，1个页的大小一般是16KB

> InnoDB为了不同目的设计多种不同类型的页，包括**存放表空间头部信息**
> 的页、**存放Change Buffer 信息**的页、**存放INODE信息**的页、**存放undo 日志信息**的页

这里说的是**存放表中记录**的那种类型的页，这种**存放记录**的页称为**索引页**（INDEX页）  

> 暂时称之为**数据页**  

# 数据页结构快览

1个页有16KB，这部分存储空间被划分为了多个部分（7部分），不同部分有不同的功能  
![image-20230421104616950](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421104616950.png)

| 名称               | 中文名                     | 占用空间 | 大小                 |
| ------------------ | -------------------------- | -------- | -------------------- |
| File Header        | 文件头部                   | 38 字节  | 页的一些通用信息     |
| Page Header        | 页面头部                   | 56 字节  | 数据页专有的一些信息 |
| Infimum + Supremum | 页面中的最小记录和最大记录 | 26 字节  | 两个虚拟的记录       |
| User Records       | 用户记录                   | 不确定   | 用户存储的记录内容   |
| Free Space         | 空闲空间                   | 不确定   | 页中尚未使用的空间   |
| Page Directory     | 页目录                     | 不确定   | 某些记录的相对位置   |
| File Trailer       | 文件尾部                   | 8 字节   | 校验页是否完整       |

# 记录在页中的存储

每插入一条记录，从**Free Space**申请一个记录大小的空间，并**将这个空间划分到UserRecords**部分。当FreeSpace部分的空间全部被UserRecords部分替代掉后，意味着该页用完。如果再插入，就需要申请新的页  


![image-20230421105227745](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421105227745.png)

## 记录头信息的秘密

```shell
mysql> CREATE TABLE page_demo(
    -> c1 INT,
    -> c2 INT,
    -> c3 VARCHAR(10000),
    -> PRIMARY KEY(c1)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
Query OK, 0 rows affected (0.03 sec)
```

![image-20230421105707019](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421105707019.png)

| 名称         | 大小（比特） | 描述                                                         |
| ------------ | ------------ | ------------------------------------------------------------ |
| 预留位1      | 1            | 没有使用                                                     |
| 预留位2      | 1            | 没有使用                                                     |
| deleted_flag | 1            | 标志该记录是否被删除                                         |
| min_rec_flag | 1            | B+ 树中每层非叶子节点中的最小的目录项记录都会添加该标记      |
| n_owned      | 4            | 一个页面中的记录会被分成若干个组，每个组中有一个记录是"带头大哥“，其余的记录都是"小弟"。带头大哥"记录的n_owned值代表该组中所有的记录条数，"小弟"记录的n_owned值都为0 |
| heap_no      | 13           | 表示当前记录在页面堆中的相对位置                             |
| record_type  | 3            | 表示当前记录的类型，0表示普通记录. 1 表示B+ 树非叶节点的目录项记录. 2 表示Infimum 记录. 3 表示Supremum 记录 |
| next_record  | 16           | 表示下一条记录的相对位置                                     |

简化一下（忽略其他**非讲解**的部分信息）  
![image-20230421110425298](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421110425298.png)

```shell
#插入4条记录
mysql> INSERT INTO page_demo VALUES(1,100,'aaaa'),(2,200,'bbbb'),(3,300,'cccc'),(4,400,'dddd');
Query OK, 4 rows affected (0.01 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

UserRecords部分的存储结构  
![image-20230421110623788](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421110623788.png)

### deleted_flag

标记当前记录是否删除：0表示没有被删除，1表示记录被删除  

> 被删除的记录不从磁盘溢出，因为移除后还需要在磁盘上**重新排列**其他的记录，带来性能消耗  
> 被删除掉的记录会组成一个垃圾链表，记录在这个链表中占用的空间称为**可重用空间**，如果之后有新纪录插入到表中，就可能**覆盖掉被删除的记录所占用的存储空间**  
> delete_flag设置为1和将被删除的记录加入到垃圾链表其实是两个阶段，后面介绍undo日志会详细讲解删除操作的详细执行过程

### min_rec_flag

B+树**每层非叶子节点**中的**最小的目录项记录**都会添加该标记

### n_onwed

### heap_no

![image-20230421140900204](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421140900204.png)

- **记录一条一条亲密无间排列的结构**称之为**堆（heap）**。把一条记录在堆中的**相对位置**称之为heap_no

- 为了**管理这个堆**，每一条记录在堆中的相对位置称为heap_no。

- 页面前面的记录heap_no比后面的小，且每**新申请一条记录的存储空间**，该条记录比**物理位置在它前面**的那条记录的heap_no大1

- 由上可知，4条记录的heap_no为**2，3，4，5**

- InnoDB的设计者自动给每个页添加了两条记录（称之**伪记录**或**虚拟记录**）。一条代表**页面中**的最小记录（也称**Infimum记录**```美 [ɪn'faɪməm]```），一条代表**页面中**的最大记录（也称**Supremum**```su'pri: m en```)。这两条伪记录也算作堆的一部分

  比较**完整记录**的大小就是**比较主键**的大小

  > 规定，用户的任何记录都比Infimum记录大，比supremum记录小

#### Infimum和Supremum记录

单独放在一个称为**Infimum和Supremum**的部分

![image-20230421144043784](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421144043784.png)



堆中记录的heap_no值在分配之后就不会发生改动了（即使删除了堆中某条记录）  
![image-20230421144426656](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421144426656.png)

### record_type

表示当前记录的**类型**，**0**表示**普通记录**（上面自己插入的记录是），**1**表示**B+树非叶节点的目录项记录**（后面索引会讲到），**2**表示**Infimum记录**，*3*表示**Supremum**记录

### next_record

表示**从当前记录的真实数据**到**下一条记录的真实数据**的距离  

> 如果该属性值为正数， 说明当前记录的下一条记录在当前记录的后面:
> 如果该属性值为负数，说明当前记录的下一条记录在当前记录的前面 

下一条记录，指的是按照主键值由小到大的顺序排列的下一条记录  
**Infimum的下一条记录**是**本页中主键值最小的用户记录**，本页中**主键值最大**的用户记录的下一条记录就是**Supremum记录**  
![image-20230421151158517](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421151158517.png)

如上，记录按照**主键从小到大**的顺序形成了一个**单向链表**  
Supremum记录的next_record值为0，即没有下一条记录了，如果删除其中一条记录  
![image-20230421151634745](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421151634745.png)

Supremum记录的n_owned由5变成了4  
**InnoDB始终维护记录的一个单向链表，链表中的各个节点是按照主键值由小到大的顺序链接起来的**  

> 为啥next_record是指向记录头信息和真实数据之间的位置，而不是整条记录的开头。
>
> 1. 这个位置刚好，向左是**记录头信息**，向右是**真实数据**
> 2. 由于变长字段长度列表、NULL值列表中的信息都是逆序存放，这样可以使**记录中靠前**的字段和他们对应的字段长度信息在内存中的距离更近，**提高高速缓存命中率**

如果第2条记录被重新插入  
![image-20230421152138295](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230421152138295.png)

# PageDirectory（页目录）



# PageHeader（页面头部）

# FileHeader（文件头部）

# FileTrailer（文件尾部）

