---
title: 索引
description: 索引
categories:
  - 学习
tags:
  - 复习
  - 复习-javaGuide
  - 复习-javaGuide-database
date: 2023-01-10 22:09:25
updated: 2023-01-11 09:09:25
---

> 转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!

# 补充索引基础知识(引自b站sgg视频)

1. 存储引擎，数据的基本单位是**页**，如果数据很少，只有一页，那就简单，是直接二分查找(不涉及磁盘IO)；如果数据很多，有好几个页，那么需要对页建立一种数据结构，能够最快定位到哪一页，然后减少磁盘IO

# 索引介绍

- 索引是一种用于**快速查询**和**检索数据**的数据结构，其本质可以看成是一种**排序好**的数据结构

  > 索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了

- 索引底层数据结构存在很多种类型，常见的索引结构有：**B树**，**B+树**和**Hash**、**红黑树**。在MySQL中，无论是Innodb还是MyIsam，都使用了B+树作为索引结构

# 索引的优缺点

**优点：**

- 使用索引可以大大**加快** 数据的检索速度（大大**减少检索的数据量**）, 这也是创建索引的最主要的原因。
- 通过创建**唯一性索引**，可以保证数据库表中**每一行数据的唯一性**。

**缺点：**

- **创建索引**和**维护索引**需要**耗费许多**时间。当对表中的数据进行**增删改**的时候，如果数据有索引，那么**索引也需要动态的修改**，会**降低 SQL 执行效率**。
- 索引需要使用**物理文件存储**，也会**耗费一定空间**

**索引一定会提高查询性能吗**

- 多数情况下，**索引查询**都是比**全表扫描**要快的。但是如果数据库的**数据量不大**，那么使用**索引也不一定能够带来很大提升**

# 索引的底层数据结构

## Hash表

- 哈希表是键值对的集合，通过**键（key）**即可**快速取出对应的值（value）**，因此哈希表可以**快速检索数据（接近O(1))**

- 为何能够通过key快速取出value呢？原因在于**哈希算法（也叫散列算法）**。通过哈希算法，我们可以**快速找到key对应的index**，找到了index也就找到了对应的value

  ```java
  hash = hashfunc(key)
  index = hash % array_size
  ```

  注意，图中keys[天蓝色]是**字符串**，**不是什么莫名其妙的人**
  ![image-20230111105843993](images/mypost/image-20230111105843993.png)

- 哈希算法有个 **Hash 冲突** 问题，也就是说**多个不同的 key 最后得到的 index 相同**。通常情况下，我们常用的解决办法是 **链地址法**。链地址法就是**将哈希冲突数据存放在链表中**。就比如 JDK1.8 之前 `HashMap` 就是通过**链地址法来解决哈希冲突**的。不过，JDK1.8 以后`HashMap`**为了减少链表过长**的时候搜索时间过长引入了**红黑树**。

- 为了减**少 Hash 冲突**的发生，一个**好的哈希函数**应该**“均匀地”将数据分布**在整个可能的哈希值集合中  

- 由于**Hash索引**不支持**顺序**和**范围查询**，假如要对表中的数据进行**排序**或者**进行范围查询**，那**Hash索引**就不行了，并且，**每次IO**只能取一个

  > 例如：  ```SELECT * FROM tb1 WHERE id < 500 ; ```
  >
  > - 这种范围查询中，B+树 优势非常大 直接遍历比500小的**叶子**节点即可
  > - 如果使用Hash索引，由于**Hash索引**是根据hash算法来定位的，难不成把1 ~499 （小于500）的数据都进行一次hash计算来定位吗？这就是Hash最大的缺点
  >
  > 这里其实说的是已经找到了索引，但是索引没有数据的情形。要么通过**hash**一个个取数据，要么利用**B+树**的特性（叶子节点有完整数据）

## B树& B+ 树

- B树也称B-树，全称为**多路平衡查找树**，B+树是**B树的一种变体**

- B树和B+树中的B是Balanced（平衡）的意思

- 目前**大部分数据库**以及**文件系统**都采用B-Tree或者其变种**B+Tree**作为索引结构

- B树&B+树两者有何异同呢

  1. B树的所有结点**既存放键（key）**也存放**数据（data）**，而B+树**只有叶子结点**存放key和data，其他**内节点**只存放key
  2. B树的叶子节点都是独立的；B+树的**叶子节点有一条引用链指向与它相邻的叶子节点**
  3. B树的检索的过程相当于**对范围内的每个结点的关键字做二分查找**，可能还没有到达叶子节点，检索就结束了。而**B+树**的检索效率比较稳定，任何查找都是从根节点到叶子节点的过程，叶子结点的顺序检索很明显
  4. B树中某个子节点，他都包括了父节点的某个节点
  5. 如图
     ![image-20230111144258302](images/mypost/image-20230111144258302.png)

- 在MySQL中，**MyISAM引擎**和**InnoDB引擎**都是使用B+Tree作为索引结构，但是，两者的实现方式有点不太一样

  > 1. MyISAM 引擎中，**B+Tree 叶节点**的 data 域存放的是**数据记录的地址**。在索引检索的时候，首先**按照 B+Tree 搜索算法**搜索索引，如果指定的 Key 存在，则**取出其 data 域的值**，然后**以 data 域的值为地址读取相应的数据记录**。这被称为“**非聚簇索引（非聚集索引）**”。【反例，B+ 树非叶子节点没有存储**数据记录的地址/数据记录本身**】
  > 2. InnoDB 引擎中，其**数据文件本身就是索引文件**。 **MyISAM** 的 索引文件和数据文件是分离的，而**InnoDB引擎**中其表数据文件本身就是按 B+Tree 组织的一个索引结构，**树的叶节点 data 域保存了完整的数据记录**。这个**索引的 key 是数据表的主键（而非地址）**，因此 InnoDB 表数据文件本身就是主索引。这被称为“**聚簇索引（聚集索引）**”，而其余的索引都作为 **辅助索引** ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在**根据主索引搜索时，直接找到 key 所在的节点即可取出数据**；在**根据辅助索引查找时**，则**需要先取出主键的值，再走一遍主索引**。
  > 3. 在设计表的时候，**不建议使用过长的字段作为主键**，也**不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂**。  
  >    原因：
  >    - InnoDB的辅助索引data域存储相应记录主键的值而不是地址。所以不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大 **(不建议使用过长的字段作为主键)**
  >    - InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效。**(不建议使用非单调的字段作为主键)**

![image-20230314113712964](images/mypost/image-20230314113712964.png)

## MySQL底层数据结构总结

![image-20230314155659459](images/mypost/image-20230314155659459.png)

## 索引类型总结

按照数据结构维度划分：

- BTree 索引：MySQL 里默认和最常用的索引类型。**只有叶子节点存储 value**，**非叶子节点只有指针和 key**。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 **B+Tree**，但二者实现方式不一样（前面已经介绍了）。
- 哈希索引：类似**键值**对的形式，一次即可定位。
- RTree 索引：**一般不会使用，仅支持 geometry 数据类型**，优势在于范围查找，**效率较低**，通常使用搜索引擎如 ElasticSearch 代替。
- **全文索引**：对文本的内容进行**分词**，进行搜索。目前只有 **`CHAR`**、**`VARCHAR`** ，**`TEXT`** 列上可以创建全文索引。一般不会使用，效率较低，通常**使用搜索引擎如 ElasticSearch 代替**。

按照底层存储方式角度划分：

- **聚簇索引**（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
- **非聚簇索引**（非聚集索引）：索引结构和数据分开存放的索引，**二级索引(辅助索引)**就属于非聚簇索引。MySQL 的 **MyISAM 引擎**，不管主键还是非主键，使用的都是非聚簇索引。

按照应用维度划分：

- **主键索引**：加速查询 + 列值**唯一**（不可以有 NULL）+ 表中只有一个。
- **普通索引**：仅**加速**查询。
- **唯一索引**：加速查询 + 列值唯一（可以有 NULL）。
- **覆盖索引**：一个**索引包含（或者说覆盖）所有需要查询的字段**的值。
- **联合索引**：**多列值组成一个索引**，专门用于组合搜索，其效率大于索引合并。
- **全文索引**：对文本的内容进行**分词**，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

MySQL 8.x 中实现的索引新特性：

- 隐藏索引：也称为不可见索引，**不会被优化器使用，但是仍然需要维护**，通常会**软删除**和**灰度发布**的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。
- 降序索引：之前的版本就支持通过 **desc 来指定索引为降序**，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持**降序索引**。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。
- **函数索引**：从 **MySQL 8.0**.13 版本开始**支持在索引中使用函数**或者**表达式的值**，也就是在索引中可以包含函数或者表达式。

# 索引类型

## 主键索引（Primary Key）

- 数据**表的主键列**，使用的就是**主键索引**
- 一张数据表只能有**一个主键**，并且主键不能为null，不能重复
- 在 MySQL 的 InnoDB 的表中，当**没有显示的指定表的主键时**，InnoDB 会自动先检查表中**是否有唯一索引**且**不允许存在 null 值**的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键
- 如图
  ![image-20230111155549265](images/mypost/image-20230111155549265.png)

## 二级索引（辅助索引）

- 二级索引又称为辅助索引，是因为**二级索引的叶子结点存储的数据是主键**。也就是说，通过二级索引，可以定位**主键**的位置（**还有值**）
- **唯一索引**、**普通索引**、**前缀索引**等索引都属于二级索引
  
  1. **唯一索引 Unique Key**：是一种约束，该索引的属性列**不能出现重复的数据**，但是**允许数据为NULL**，一张表允许创建**多个唯一索引**。建立唯一索引的目的多是为了**该属性列的数据的唯一性**，而不是为了查询效率
  
  2. **普通索引 Index**：普通索引的唯一作用就是为了**快速查询**数据，一张表允许创建**多个普通索引**，并允许**数据重复**和**NULL**
  
  3. **前缀索引 Prefix**：前缀索引只适用于**字符串类型**的数据。前缀索引是对**文本的前几个字符创建索引**，相**比普通索引建立的数据更小**，因为**只取前几个**字符
  
  4. **全文索引Full Text**：全文索引主要是为了检索**大文本数据中的关键字**的信息，是目前搜索引擎数据库使用的一种技术。
  
     > Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。 
  
- 二级索引：
  ![image-20230112085212547](images/mypost/image-20230112085212547.png)

# 聚簇索引与非聚簇索引

## 聚簇索引（聚集索引）

- 聚簇索引介绍
  1. 聚簇索引即**索引结构和数据一起存放**的索引，并**不是一种单独的索引类型**。InnoDB中的**主键索引**就属于**聚簇索引**
  2. MySQL中**InnoDB引擎的表**的**.ibd 文件**就包含了**该表的索引**和**数据**，对于InnoDB引擎表来说，该表的**索引（B+树）**的**每个非叶子节点存储索引(和页地址)**，叶子结点存储**索引**和**索引对应的数据**
- 聚簇索引的优缺点
  - 优点
    1. **查询速度非常快**：聚簇索引的**查询速度**非常的**快**，因为**整个B+树**本身就**是一颗多差平衡树**，**叶子节点**也都是**有序**的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引**少了一次读取数据的IO操作**
    2. **对排序查找和范围查找优化**：聚簇索引对于逐渐的排序查找和范围查找速度非常快
  - 缺点
    1. **依赖于有序的数据**：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在**插入时排序**。如果数据是整型还好，否则**类似于字符串或UUID这种又长有难比较的数据**，**插入**或**查找**的**速度较慢**
    2. **更新代价大**：如果对**索引列的数据被修改**时，那么**对应的索引也将会被修改**，而且**聚簇索引的叶子节点还存放着数据**，修改代价肯定是较大的，所以对于主键索引来说，**主键一般都是不可被修改**的

## 非聚簇索引（非聚集索引）

**优点**：

**更新代价比聚簇索引要小**。因为**非聚簇索引的叶子节点**是不存放数据的

**缺点**：

- **依赖于有序数据**：跟聚簇索引一样，非聚簇索引也依赖于有序数据
- **可能会二次查询（回表）**：这应该是非聚簇索引**最大的缺点**了。 当**查到索引对应的指针或主键**后，可能还需要**根据指针或主键**再**到数据文件或表中查询**

**MySQL的表的文件截图**：
![image-20230113212438093](images/mypost/image-20230113212438093.png)

**聚簇索引和非聚簇索引**：  
![image-20230113212558682](images/mypost/image-20230113212558682.png)

**聚簇索引一定回表查询吗(覆盖索引)**

**非聚簇索引不一定回表查询**

> 试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。
>
> ```sql
>  SELECT name FROM table WHERE name='guang19';
> ```
>
> 那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。
>
> 即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的**主键索引的叶子节点存放的是指针**。但是！**如果 SQL 查的就是主键(本身)呢?**
>
> ```sql
> SELECT id FROM table WHERE id=1;
> ```
>
> 主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了

# 覆盖索引和联合索引

## 覆盖索引

- 如果一个**索引包含（或者说覆盖）所有需要查询的字段的值**，我们就称之为“覆盖索引”。（**也就是不用回表**）

  > 我们知道在 InnoDB 存储引擎中，如果不是**主键索引（叶子节点存储的是主键+列值）**，最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

- **覆盖索引**即需要**查询的字段正好事索引的字段**，那么直接根据该索引，就可以查到数据了，而无需回表查询

  > 如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。
  >
  > 再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。

- 我觉得覆盖索引要在联合索引上体现的话功能会比较突出

![image-20230114170030609](images/mypost/image-20230114170030609.png)

## 联合索引

使用**表中的多个字段创建索引**，也就是**联合索引**，也叫**组合索引**，或**复合索引**

## 最左前缀匹配原则

- 最左前缀匹配原则指的是，在使用**联合索引**时，**MySQL** 会根据**联合索引中的字段顺序**，**从左到右依次到查询条件中去匹配**，如果查询条件中**存在与联合索引中最左侧字段相匹配**的字段，则就会使用**该字段过滤一批数据**，**直至联合索引中全部字段**匹配完成，或者在**执行过程中遇到范围查询**，如 **`>`**、**`<`**、**`between`** 和 **`以%开头的like查询`** 等条件，才会停止匹配。
- 所以，我们在使用联合索引时，可以将**区分度高的字段放在最左边**，这也可以过滤更多数据

# 索引下推

**索引下推（Index Condition Pushdown）** 是 **MySQL 5.6** 版本中提供的一项**索引优化**功能，可以在**非聚簇索引遍历过程**中，对（即**能用索引先用索引**）**索引中包含的字段先做判断**，**过滤掉不符合条件的记录**，减少回表次数。

> 例子：  
> 对于```SELECT * from user where  name like '陈%' and age=20```这条语句    
> 其中主要几个字段有：id、name、age、address。建立联合索引（name，age）
>
> > 最关键的一点：
> > **组合索引满足最左匹配，但是遇到非等值判断时匹配停止。**
> > **name like '陈%' 不是等值匹配，所以 age = 20 这里就用不上 (name,age) 组合索引了**。如果没有索引下推，组合索引只能用到 name，age 的判定就需要回表才能做了。5.6之后有了索引下推，age = 20 可以直接在组合索引里判定。
>
> ![image-20230114171107653](images/mypost/image-20230114171107653.png)
>
> 1. 5.6之前的版本是没有索引下推这个优化的，会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要**回表两次**
> 2. 5.6版本添加了索引下推这个优化
>    ![image-20230114171144075](images/mypost/image-20230114171144075.png)
>    InnoDB并没有忽略age这个字段，而是**在索引内部就判断了age是否等于20**，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次

# 争取使用索引的一些建议

## 选择合适的字段创建索引

- **不为 NULL 的字段** ：索引字段的数据应该**尽量不为 NULL**，因为**对于数据为 NULL 的字段，数据库较难优化**。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的**短值或短字符**作为替代。
- **被频繁查询的字段** ：我们创建索引的字段应该是**查询操作非常频繁**的字段。
- **被作为条件查询的字段** ：被作为 **WHERE 条件查询的字段**，应该被考虑建立索引。
- **频繁需要排序的字段** ：索引已经排序，这样查询可以利用索引的排序，**加快排序查询时间**。
- **被经常频繁用于连接的字段** ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列**涉及到表与表的关系**。对于频繁被连接查询的字段，可以考虑建立索引，**提高多表连接查询的效率**

## 被频繁更新的字段应该慎重建索引

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段**不被经常查询，反而被经常修改**，那么就更**不应该**在这种字段上建立索引了。

## 尽可能地考虑建立联合索引而不是单列索引

因为索引是需要占用磁盘空间的，可以简单理解为**每个索引都对应着一颗 B+树**。如果一个表的字段过多，**索引过多**，那么当这个表的数据达到一个体量后，**索引占用的空间也是很多**的，且**修改索引**时，**耗费的时间也是较多**的。如果是联合索引，**多个字段在一个索引上**，那么将会**节约很大磁盘空间**，且**修改数据的操作效率也会提升**。

## 注意避免冗余索引

- 冗余索引指的是**索引的功能相同**，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引

  > （name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引

## 考虑在字符串类型的字段上使用前缀索引代替普通索引

**前缀索引仅限于字符串**类型，较普通索引会占用更小的空间，所以可以考虑使用**前缀索引带替普通索引**。

## 避免索引失效

- 使用 `SELECT *` 进行查询;

- 创建了**组合索引**，但查询条件**未准守最左匹配**原则;

- 在索引列上进行计算、函数、类型转换等操作;

- 以 % 开头的 LIKE 查询比如 `like '%abc';`  

  > - %在左边，即使有索引，也会失效
  > - 只有当%在右边时，才会生效

- 查询条件中使用 or，**且 or 的前后**条件中**有一个列没有索引**，**涉及的索引都不会被使用到**(也就是说，反正都是要全表扫描，所以就不用索引了)

## 删除长期未使用的索引

- 删除长期未使用的索引，**不用的索引的存在会造成不必要的性能损耗**

- MySQL 5.7 可以通过查询 **sys 库的 schema_unused_indexes** 视图来查询哪些索引从未被使用