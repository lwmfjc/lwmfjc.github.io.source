---
title: 堆
description: 堆
categories:
  - 学习
tags:
  - 复习
  - 复习-javaGuide
  - 复习-javaGuide-data-structure
date: 2023-01-06 10:46:19
updated: 2023-01-06 10:46:19
---

> 转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!

# 什么是堆

- 堆是**满足以下条件**的树
  堆中每一个节点值都**大于等于（或小于等于）子树中所有节点**。或者说，任意一个节点的值**都大于等于（或小于等于）**所有子节点的值

  > 大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。

  - **堆不一定是完全二叉树**，为了方便**存储**和**索引**，我们通常用完全二叉树的形式来表示堆  
    广为人知的**斐波那契堆**和**二项堆**就不是完全二叉树，它们甚至都**不是二叉树**
  -  (二叉)堆是一个数组，它可以被看成是一个**近似的完全二叉树**
  
- 下面给出的图是否是堆（通过定义）

  1，2是。
  3不是。
  ![image-20230108214044120](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230108214044120.png)

# 堆的用途

- 当我们**只关心**所有数据中的**最大值**或者**最小值**，存在**多次获取最大值**或者**最小值**，多次插入或删除数据时，就可以使用堆。

  > 有小伙伴可能会想到用**有序数组**，初始化一个有序数组时间复杂度是 `O(nlog(n))`**[也就是将一堆数字乱序排序，最快是O(nlog(n))]**，查找最大值或者最小值时间复杂度都是 `O(1)`，但是，涉及到更新（插入或删除）数据时，时间复杂度为 `O(n)`，即使是使用复杂度为 `O(log(n))` 的二分法找到要插入或者删除的数据，在移动数据时也需要 `O(n)` 的时间复杂度。

- 相对于有序数组而言，堆的主要优势在于更新数据效率较高

  - 堆的**初始化时间复杂度**为O(nlog(n))，堆可以做到**O(1)**的时间复杂度取出**最大值**或者**最小值**，**O(log(n))**的时间复杂度**插入或者删除**数据

# 堆的分类

- 堆分为**最大堆**和**最小堆**，二者的区别在于节点的**排序方式**
  - 最大堆：堆中的每一个节点的值**都大于**子树中**所有节点**的值
  - 最小堆：堆中的每一个节点的值**都小于**子树中**所有节点**的值
- 如图，图1是最大堆，图2是最小堆
  ![image-20230108221541796](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230108221541796.png)

# 堆的存储

- 由于**完全二叉树的优秀性质**，**利用数组存储二叉树**即节省空间，又**方便索引**（若根结点的序号为1，那么对于树中任意节点i，其左子节点序号为 `2*i`，右子节点序号为 `2*i+1`）。
- 为了**方便存储**和**索引**，**（二叉）堆**可以用**完全二叉树**的形式进行存储。存储的方式如下图所示
  ![image-20230108222619449](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230108222619449.png)

# 堆的操作

## 插入元素

## 删除堆顶元素

## 堆的操作总结

# 堆排序

## 建堆

## 排序