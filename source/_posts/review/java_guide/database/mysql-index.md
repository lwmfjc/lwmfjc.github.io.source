---
title: 索引
description: 索引
categories:
  - 学习
tags:
  - 复习
  - 复习-javaGuide
  - 复习-javaGuide-database
date: 2023-01-10 22:09:25
updated: 2023-01-11 09:09:25
---

> 转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!

# 索引介绍

- 索引是一种用于**快速查询**和**检索数据**的数据结构，其本质可以看成是一种**排序好**的数据结构

  > 索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了

- 索引底层数据结构存在很多种类型，常见的索引结构有：**B树**，**B+树**和**Hash**、**红黑树**。在MySQL中，无论是Innodb还是MyIsam，都使用了B+树作为索引结构

# 索引的优缺点

**优点：**

- 使用索引可以大大**加快** 数据的检索速度（大大**减少检索的数据量**）, 这也是创建索引的最主要的原因。
- 通过创建**唯一性索引**，可以保证数据库表中**每一行数据的唯一性**。

**缺点：**

- **创建索引**和**维护索引**需要**耗费许多**时间。当对表中的数据进行**增删改**的时候，如果数据有索引，那么**索引也需要动态的修改**，会**降低 SQL 执行效率**。
- 索引需要使用**物理文件存储**，也会**耗费一定空间**

**索引一定会提高查询性能吗**

- 多数情况下，**索引查询**都是比**全表扫描**要快的。但是如果数据库的**数据量不大**，那么使用**索引也不一定能够带来很大提升**

# 索引的底层数据结构

## Hash表

- 哈希表是键值对的集合，通过**键（key）**即可**快速取出对应的值（value）**，因此哈希表可以**快速检索数据（接近O(1))**

- 为何能够通过key快速取出value呢？原因在于**哈希算法（也叫散列算法）**。通过哈希算法，我们可以**快速找到key对应的index**，找到了index也就找到了对应的value

  ```java
  hash = hashfunc(key)
  index = hash % array_size
  ```

  注意，图中keys是**字符串**，**不是什么莫名其妙的人**
  ![image-20230111105843993](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230111105843993.png)

- 哈希算法有个 **Hash 冲突** 问题，也就是说**多个不同的 key 最后得到的 index 相同**。通常情况下，我们常用的解决办法是 **链地址法**。链地址法就是**将哈希冲突数据存放在链表中**。就比如 JDK1.8 之前 `HashMap` 就是通过**链地址法来解决哈希冲突**的。不过，JDK1.8 以后`HashMap`**为了减少链表过长**的时候搜索时间过长引入了**红黑树**。

- 为了减**少 Hash 冲突**的发生，一个**好的哈希函数**应该**“均匀地”将数据分布**在整个可能的哈希值集合中  

- 由于**Hash索引**不支持**顺序**和**范围查询**，假如要对表中的数据进行**排序**或者**进行范围查询**，那**Hash索引**就不行了，并且，**每次IO**只能取一个

  > 例如：  ```SELECT * FROM tb1 WHERE id < 500 ; ```
  >
  > - 这种范围查询中，B+树 优势非常大 直接遍历比500小的叶子节点即可
  > - 如果使用Hash索引，由于**Hash索引**是根据hash算法来定位的，难不成把1 ~499 （小于500）的数据都进行一次hash计算来定位吗？这就是Hash最大的缺点

## B树& B+ 树

- B树也称B-树，全称为**多路平衡查找树**，B+树是**B树的一种变体**

- B树和B+树中的B是Balanced（平衡）的意思

- 目前**大部分数据库**以及**文件系统**都采用B-Tree或者其变种**B+Tree**作为索引结构

- B树&B+树两者有何异同呢

  1. B树的所有结点**既存放键（key）**也存放**数据（data）**，而B+树**只有叶子结点**存放key和data，其他**内节点**只存放key
  2. B树的叶子节点都是独立的；B+树的**叶子节点有一条引用链指向与它相邻的叶子节点**
  3. B树的检索的过程相当于**对范围内的每个结点的关键字做二分查找**，可能还没有到达叶子节点，检索就结束了。而**B+树**的检索效率比较稳定，任何查找都是从根节点到叶子节点的过程，叶子结点的顺序检索很明显
  4. 如图
     ![image-20230111144258302](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230111144258302.png)

- 在MySQL中，**MyISAM引擎**和**InnoDB引擎**都是使用B+Tree作为索引结构，但是，两者的实现方式有点不太一样

  > 1. MyISAM 引擎中，**B+Tree 叶节点**的 data 域存放的是**数据记录的地址**。在索引检索的时候，首先**按照 B+Tree 搜索算法**搜索索引，如果指定的 Key 存在，则**取出其 data 域的值**，然后**以 data 域的值为地址读取相应的数据记录**。这被称为“**非聚簇索引（非聚集索引）**”。
  > 2. InnoDB 引擎中，其**数据文件本身就是索引文件**。 **MyISAM** 的 索引文件和数据文件是分离的，而**InnoDB引擎**中其表数据文件本身就是按 B+Tree 组织的一个索引结构，**树的叶节点 data 域保存了完整的数据记录**。这个**索引的 key 是数据表的主键（而非地址）**，因此 InnoDB 表数据文件本身就是主索引。这被称为“**聚簇索引（聚集索引）**”，而其余的索引都作为 **辅助索引** ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在**根据主索引搜索时，直接找到 key 所在的节点即可取出数据**；在**根据辅助索引查找时**，则**需要先取出主键的值，再走一遍主索引**。
  > 3. 在设计表的时候，**不建议使用过长的字段作为主键**，也**不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂**。  
  >    原因：
  >    - InnoDB的辅助索引data域存储相应记录主键的值而不是地址。所以不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大 **(不建议使用过长的字段作为主键)**
  >    - InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效。**(不建议使用非单调的字段作为主键)**

# 索引类型

## 主键索引（Primary Key）

- 数据**表的主键列**，使用的就是**主键索引**
- 一张数据表只能有**一个主键**，并且主键不能为null，不能重复
- 在 MySQL 的 InnoDB 的表中，当**没有显示的指定表的主键时**，InnoDB 会自动先检查表中**是否有唯一索引**且**不允许存在 null 值**的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键
- 如图
  ![image-20230111155549265](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230111155549265.png)

## 二级索引（辅助索引）

- 二级索引又称为辅助索引，是因为**二级索引的叶子结点存储的数据是主键**。也就是说，通过二级索引，可以定位**主键**的位置（**还有值**）
- 唯一索引、普通索引、前缀索引等索引都属于二级索引
  1. **唯一索引 Unique Key**：是一种约束，该索引的属性列**不能出现重复的数据**，但是**允许数据为NULL**，一张表允许创建**多个唯一索引**。建立唯一索引的目的多是为了**该属性列的数据的唯一性**，而不是为了查询效率
  
  2. **普通索引 Index**：普通索引的唯一作用就是为了**快速查询**数据，一张表允许创建**多个普通索引**，并允许**数据重复**和**NULL**
  
  3. **前缀索引 Prefix**：前缀索引只适用于**字符串类型**的数据。前缀索引是对**文本的前几个字符创建索引**，相**比普通索引建立的数据更小**，因为**只取前几个**字符
  
  4. **全文索引Full Text**：全文索引主要是为了检索**大文本数据中的关键字**的信息，是目前搜索引擎数据库使用的一种技术。
  
     > Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。 
  
- 二级索引：
  ![image-20230112085212547](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230112085212547.png)

# 聚簇索引与非聚簇索引

## 聚簇索引（聚集索引）

- 聚簇索引介绍
  1. 聚簇索引即**索引结构和数据一起存放**的索引，并**不是一种单独的索引类型**。InnoDB中的**主键索引**就属于**聚簇索引**
  2. MySQL中**InnoDB引擎的表**的**.ibd 文件**就包含了**该表的索引**和**数据**，对于InnoDB引擎表来说，该表的**索引（B+树）**的**每个非叶子节点存储索引**，叶子结点存储**索引**和**索引对应的数据**
- 聚簇索引的优缺点
  - 优点
    1. **查询速度非常快**：聚簇索引的**查询速度**非常的**快**，因为**整个B+树**本身就**是一颗多差平衡树**，**叶子节点**也都是**有序**的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引**少了一次读取数据的IO操作**
    2. **对排序查找和范围查找优化**：聚簇索引对于逐渐的排序查找和范围查找速度非常快
  - 缺点
    1. **依赖于有序的数据**：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在**插入时排序**。如果数据是整型还好，否则**类似于字符串或UUID这种又长有难比较的数据**，**插入**或**查找**的**速度较慢**
    2. **更新代价大**：如果对**索引列的数据被修改**时，那么**对应的索引也将会被修改**，而且**聚簇索引的叶子节点还存放着数据**，修改代价肯定是较大的，所以对于主键索引来说，**主键一般都是不可被修改**的

## 非聚簇索引（非聚集索引）

**优点**：

**更新代价比聚簇索引要小**。因为**非聚簇索引的叶子节点**是不存放数据的

**缺点**：

- **依赖于有序数据**：跟聚簇索引一样，非聚簇索引也依赖于有序数据
- **可能会二次查询（回表）**：这应该是非聚簇索引**最大的缺点**了。 当**查到索引对应的指针或主键**后，可能还需要**根据指针或主键**再**到数据文件或表中查询**

**MySQL的表的文件截图**：
![image-20230113212438093](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230113212438093.png)

**聚簇索引和非聚簇索引**：  
![image-20230113212558682](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230113212558682.png)

**聚簇索引一定回表查询吗(覆盖索引)**

**非聚簇索引不一定回表查询**

> 试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。
>
> ```sql
>  SELECT name FROM table WHERE name='guang19';
> ```
>
> 那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。
>
> 即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！**如果 SQL 查的就是主键呢?**
>
> ```sql
> SELECT id FROM table WHERE id=1;
> ```
>
> 主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了

# 覆盖索引和联合索引

## 覆盖索引

## 联合索引

## 最左前缀匹配原则

# 索引下推

# 争取使用索引的一些建议

## 选择合适的字段创建索引

## 被频繁更新的字段应该慎重建索引

## 尽可能地考虑建立联合索引而不是单列索引