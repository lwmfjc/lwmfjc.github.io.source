---
title: MySQL高性能优化规范建议总结
description: MySQL高性能优化规范建议总结
categories:
  - 学习
tags:
  - 复习
  - 复习-javaGuide
  - 复习-javaGuide-database
date: 2023-01-20 11:36:34
updated: 2023-01-23 09:24:34
---

> 转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!

> 索引优化相关  
>
> 1. in 代替 or
> 2. not exist 代替 not in

# 数据库命名规范

- 所有**数据库对象**名称必须使用**小写字母**并用**下划线分割**
- 所有数据库对象名称**禁止使用 MySQL 保留关键字**（如果表名中包含关键字查询时，需要将其用单引号括起来）
- 数据库对象的命名要能做到**见名识意**，并且最好**不要超过 32 个**字符
- **临时库表**必须**以 `tmp_` 为前缀**并以日期为后缀，**备份表**必须**以 `bak_` 为前缀**并**以日期 (时间戳) 为后缀**
- 所有**存储相同数据的列名和列类型**必须一致（**一般作为关联列**，如果查询时关联列**类型不一致会自动进行数据类型隐式转换**，会**造成列上的索引失效**，导致查询效率降低）

# 数据库基本设计规范

## 所有表必须使用InnoDB存储引擎

- 没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）。
- InnoDB 支持**事务**，支持**行级锁**，更好的**恢复性**，**高并发**下性能更好

## 数据库和表的字符集统一使用UTF-8

**兼容性**更好，**统一字符集**可以避免由于字符集转换产生的**乱码**，不同的字符集进行比较前需要进行转换会造成**索引失效**，如果数据库中有**存储 emoji 表情**的需要，字符集需要采用 **utf8mb4** 字符集。

参考文章：

- [MySQL 字符集不一致导致索引失效的一个真实案例open in new window](https://blog.csdn.net/horses/article/details/107243447)
- [MySQL 字符集详解

## 所有表和字段都需要添加注释

使用 **comment 从句添加表**和**列的备注**，从一开始就进行数据字典的维护

## 尽量控制单表数据量的大小，建议控制在500万以内

- 500 万并不是 MySQL 数据库的限制，**过大会造成修改表结构**，**备份**，**恢复**都会有很大的问题。

- 可以用**历史数据归档（应用于日志数据）**，**分库分表（应用于业务数据）**等手段来控制数据量大小

## 谨慎使用MySQL分区表

- 分区表在**物理上表现为多个文件**，在**逻辑上表现为一个表**；

- 谨慎选择分区键，**跨分区查询效率可能更低**；
- 建议采用**物理分表的方式管理大数据**。

## 经常一起使用的列放到一个表中

避免更多的关联操作。

## 禁止在表中建立预留字段

- 预留字段的命名**很难做到见名识义**。
- 预留字段**无法确认存储的数据类型**，所以**无法选择合适的类型**。
- **对预留字段类型的修改，会对表进行锁定**

## 禁止在数据库中存储文本（比如图片）这类大的二进制数据

- 在数据库中存储文件会严重**影响数据库性能**，**消耗过多存储空间**。

- 文件（比如图片）这类大的二进制数据**通常存储于文件服务器**，数据库**只存储文件地址信息**。

## 不要被数据库范式所束缚

一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在**进行查询时需要对多张表进行关联查询**，有时为了**提高查询效率**，会**降低范式的要求**，在表中**保存一定的冗余**信息，也叫做**反范式**。但要注意反范式一定要适度。

## 禁止在线上做数据库压力测试

## 禁止从开发环境、测试环境，直接连接生产环境数据库

**安全隐患极大，要对生产环境抱有敬畏之心！**

# 数据库字段设计规范

## 优先选择符合存储需要的最小数据类型

**Byte：字节**  
![image-20230123123412164](images/mypost/image-20230123123412164.png)

存储字节越小，**占用也就空间越小**，**性能也越好**。

**a.某些字符串可以转换成数字类型存储比如可以将 IP 地址转换成整型数据。**

数字是连续的，性能更好，占用空间也更小。

MySQL 提供了两个方法来**处理 ip 地址**

- `INET_ATON()` ： 把 ip 转为**无符号整型** (4-8 位)
- `INET_NTOA()` :把整型的 ip 转为地址

插入数据前，先用 `INET_ATON()` 把 ip 地址转为整型，显示数据时，使用 `INET_NTOA()` 把整型的 ip 地址转为地址显示即可。

**b.对于非负型的数据 (如自增 ID,整型 IP，年龄) 来说,要优先使用无符号整型来存储。**

无符号相对于有符号可以多出一倍的存储空间

```sql
SIGNED INT -2147483648~2147483647
UNSIGNED INT 0~4294967295
```

**c.小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型。**

## 避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据

**a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。**

MySQL **内存临时表不支持 TEXT、BLOB 这样的大数据类型**，如果查询中包含这样的数据，在**排序**等操作时，就**不能使用内存临时表**，必须**使用磁盘临时表**进行。而且对于这种数据，MySQL 还是要进行**二次查询**，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。

如果一定要使用，建议**把 BLOB 或是 TEXT 列分离到单独的扩展表**中，查询时一定不要使用 `select *`而**只需要取出必要的列**，**不需要 TEXT 列的数据时不要对该列进行查询**。

**2、TEXT 或 BLOB 类型只能使用前缀索引**

因为 **MySQL 对索引字段长度是有限制**的，所以 **TEXT 类型只能使用前缀索引**，并且 **TEXT 列上是不能有默认值**的

## 避免使用ENUM类型

**原因**：  

- 修改 ENUM 值需要使用 **ALTER 语句**；
- ENUM 类型的 **ORDER BY 操作效率低**，需要额外操作；
- ENUM 数据类型**存在一些限制比如建议不要使用数值作为 ENUM 的枚举值**。

相关阅读：[是否推荐使用 MySQL 的 enum 类型？ - 架构文摘 - 知乎open in new window](https://www.zhihu.com/question/404422255/answer/1661698499) 

## 尽可能把所有的列定义为NOT NULL

除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。

- **索引 NULL 列需要额外的空间**来保存，所以要占用更多的空间；  

  > **该位指示了该行数据中是否有NULL值，有则使用1来表示，该部分占的字节大小大概为1字节**，比如当NULL标志位为06时，06转换为二进制为110，表示第二列和第三列为NULL。
- 进行**比较和计算时要对 NULL 值做特别的处理**。

相关阅读：[技术分享 | MySQL 默认值选型（是空，还是 NULL）open in new window](https://opensource.actionsky.com/20190710-mysql/) 。  

## 使用TIMESTAMP(4个字节)或DATETIME类型（8个字节）存储时间

- TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07

- **TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高**

- **超出 TIMESTAMP 取值范围的使用 DATETIME 类型**存储

**反之**， 经常会有人用字符串存储日期型的数据**（不正确的做法）**

- 缺点 1：**无法用日期函数**进行**计算**和**比较**
- 缺点 2：用**字符串存储日期要占用更多**的空间

## 同财务相关的金额类数据必须使用decimal类型

- **非精准浮点** ：float,double
- **精准浮点** ：decimal

**decimal** 类型为精准浮点数，在**计算时不会丢失精度**。**占用空间由定义的宽度决定**，**每 4 个字节可以存储 9 位数字**，并且**小数点要占用一个字节**。并且，**decimal 可用于存储比 bigint 更大的整型数据**

不过， 由于 decimal 需要**额外的空间**和**计算开销**，应该**尽量**只在需要对数据进行**精确计算**时才使用 decimal 。

## 单表不要包含过多字段

如果一个表包含过多字段的话，可以考虑将其**分解成多个表**，必要时**增加中间表进行关联**。

# 索引设计规范

## 限制每张表上的索引数量，建议单张表索引不超过5个

-  索引并不是越多越好！索引可以**提高效率**同样可以**降低效率**。

- 索引可以增加查询效率，但同样也会**降低插入**和**更新**的效率，甚至有些情况下会**降低查询效率**。

  > 因为 MySQL **优化器**在选择如何优化查询时，会根据统一信息，**对每一个可以用到的索引来进行评估**，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会**增加 MySQL 优化器生成执行计划的时间**，同样会**降低查询性能**。

## 禁止使用全文索引

全文索引不适用于 OLTP 场景。  

> On-Line Transaction Processing联机事务处理过程(*OLTP*)，也称为面向交易的处理过程

## 禁止给表中的每一列都建立单独的索引

5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个**联合索引**的查询方式好  

> 尽量使用**联合索引**

## 每个InnoDB表必须有个主键

- InnoDB 是一种**索引组织表**：数据的**存储的逻辑顺序**和**索引的顺序**是相同的。每个表都可以有多个索引，但是**表的存储顺序只能有一种**。
- InnoDB 是按照**主键索引的顺序**来组织表的
  - **不要使用更新频繁的列**作为主键，**不适用(使用)多列主键**（相当于联合索引）
  - 不要使用 **UUID,MD5,HASH,字符串**列作为主键（无法保证数据的**顺序增长**）
  - 主键**建议使用自增 ID** 值

## 常见索引列建议

- 出现在 **SELECT、UPDATE、DELETE** 语句的 **WHERE 从句中的列**

- 包含在 **ORDER BY**、**GROUP BY**、**DISTINCT** 中的字段

- 并不要将符合 1 和 2 中的字段的列都建立一个索引， **通常将 1、2 中的字段建立联合索引**效果更好

- **多表 join 的关联列**

## 如何选择索引列的顺序

建立**索引的目的**是：希望**通过索引进行数据查找**，**减少随机 IO**，**增加查询性能** ，索引能**过滤出越少**的数据，则**从磁盘中读入的数据也就越少**。

- **区分度最高**的放在联合索引的**最左侧**（区分度=**列中不同值的数量**/列的总行数）
- 尽量把字段长度小的列放在联合索引的最左侧（因为**字段长度越小**，**一页能存储的数据量越大**，**IO 性能也就越好**）
- 使用**最频繁的列**放到联合索引的左侧（这样可以比较少的建立一些索引）

## 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）

- **重复索**引示例：primary key(id)、index(id)、unique index(id)
- **冗余索引**示例：index(a,b,c)、index(a,b)、index(a)

## 对于频繁的查询有优先考虑使用覆盖索引

> **覆盖索引**：就是**包含了所有查询字段** (where,select,order by,group by 包含的字段) 的索引

**覆盖索引的好处：**

- **避免 InnoDB 表进行索引的二次查询:** InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，**二级索引在叶子节点中所保存的是行的主键信息**，如果是用二级索引查询数据的话，在查找到相应的键值后，**还要通过主键进行二次查询**才能获取我们真实所需要的数据。而在**覆盖索引中，二级索引的键值中可以获取所有的数据**，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。
- **可以把随机 IO 变成顺序 IO 加快查询效率:** 由于覆盖索引是**按键值的顺序存储**的，对于 IO 密集型的**范围查找**来说，对比随机从磁盘读取每一行的数据 **IO 要少的多**，因此利用覆盖索引在访问时也可以**把磁盘的随机读取的 IO** 转变成**索引查找的顺序 IO**。

## 索引SET规范

**尽量避免使用外键约束**

- **不建议使用外键约束（foreign key）**，但一定要在表与表之间的**关联键上建立索引**
- 外键可用于**保证数据的参照完整性**，但建议**在业务端实现**
- 外键会**影响父表和子表的写操作**从而降低性能

# 数据库SQL开发规范

## 优化对性能影响较大的SQL语句

要找到**最需要优化**的 SQL 语句。要么是**使用最频繁**的语句，要么是**优化后提高最明显**的语句，可以通过**查询 MySQL 的慢查询日志**来发现需要进行优化的 SQL 语句；

## 充分利用表上已经存在的索引

- 避免使用双%号的查询条件。如：`a like '%123%'`，（**如果无前置%,只有后置%，是可以用到列上的索引的**）

- 一个 SQL 只能利用到**复合索引中的一列**进行**范围**查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。

  > https://blog.csdn.net/qq_33589510/article/details/123038988  
  > (a=1 b=1 c=1) (a=1 b=2 c=1) (a=1 b=2 c=3)   
  > (a=2 b=2 c=3) (a=2 b=2 c=5) (a=2 b=5 c=1) (a=2 b=5 c=2)  
  >  (a=3 b=0 c=1) (a=3 b=3 c=5) (a=3 b=8 c=6)  
  > 假设有一条SQL为```select a,b,c from table where a = 2 and b >1 and c = 2```，那么索引c就用不到了，因为有可能b查找后c是无序的了

- 在定义联合索引时，如果 a 列要用到**范围查找**的话，就要把 **a 列放到联合索引的右侧**，使用 **left join** 或 **not exists** 来优化 not in 操作，因为 **not in 也通常会使用索引失效**。  

  > 这个的意思是，如果有两个列，b，a都是索引  
  > SELECT * FROM table WHERE a > 1 and b = 2;   
  > 对于上面这句，如果建立(a，b)，那么只有a会用得到。而如果建立(b，a)，则都能用上    
  > （**如果没有b= 2，那么（b，a）索引就用不上了**）

## 禁止使用SELECT * 必须使用SELECT <字段列表> 查询

- `SELECT *` 消耗**更多的 CPU** 和 **IO** 以网络带宽资源
- `SELECT *` **无法使用覆盖索引**
- `SELECT <字段列表>` 可**减少表结构变更带来的影响**

## 禁止使用不含字段列表的INSERT语句

如：

```sql
insert into t values ('a','b','c');
```

应使用：

```sql
insert into t(c1,c2,c3) values ('a','b','c');
```

## 建议使用预编译语句进行数据库操作

（这里应该是**针对jdbc**，**不是指mybatis**的情况）  

> 例子：  
>
> 1. MySQL执行预编译分为如三步：  
>
>    > - 执行预编译语句，例如：prepare myfun from 'select * from t_book where bid=?'
>    >
>    > - 设置变量，例如：set @str='b1'
>    > - 执行语句，例如：execute myfun using @str
>    >
>    > 如果需要再次执行myfun，那么就不再需要第一步，即不需要再编译语句了：
>    >
>    > - 设置变量，例如：set @str='b2'
>    > - 执行语句，例如：execute myfun using @str
>    >
>    > 通过查看MySQL日志可以看到执行的过程：
>    >
>    > ![img](images/mypost/202074104855490.png)
>
> 2. **使用Statement执行预编译**  
>    **使用Statement执行预编译就是把上面的SQL语句执行一次。   **  
>
>    ```java
>    Connection con = JdbcUtils.getConnection();
>    Statement stmt = con.createStatement();
>    stmt.executeUpdate("prepare myfun from 'select * from t_book where bid=?'");
>    stmt.executeUpdate("set @str='b1'");
>    ResultSet rs = stmt.executeQuery("execute myfun using @str");
>    while(rs.next()) {
>      System.out.print(rs.getString(1) + ", ");
>      System.out.print(rs.getString(2) + ", ");
>      System.out.print(rs.getString(3) + ", ");
>      System.out.println(rs.getString(4));
>    }
>     
>    stmt.executeUpdate("set @str='b2'");
>    rs = stmt.executeQuery("execute myfun using @str");
>     
>    while(rs.next()) {
>      System.out.print(rs.getString(1) + ", ");
>      System.out.print(rs.getString(2) + ", ");
>      System.out.print(rs.getString(3) + ", ");
>      System.out.println(rs.getString(4));
>    }
>     
>    rs.close();
>    stmt.close();
>    con.close();
>    ```
>
> 3. useServerPrepStmts参数   
>    默认使用PreparedStatement是不能执行预编译的，这需要在url中给出useServerPrepStmts=true参数（MySQL Server 4.1之前的版本是不支持预编译的，而Connector/J在5.0.5以后的版本，默认是没有开启预编译功能的）。
>
>    例如：jdbc:mysql://localhost:3306/test?useServerPrepStmts=true

- 预编译语句可以**重复使用这些计划，减少 SQL 编译所需要的时间**，还可以解决动态 SQL 所带来的 SQL 注入的问题。

- **只传参数，比传递 SQL 语句更高效**。

- **相同语句可以一次解析，多次使**用，提高处理效率。

## 避免数据类型的隐式转换

隐式转换会导致索引失效如:
这里id应该不是字符型(**但是这个好像是例外，如果字段是数字，而查询的是字符，索引还是有效的**)

```sql
select name,phone from customer where id = '111';
```

详细解读可以看：[MySQL 中的隐式转换造成的索引失效](https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html) 这篇文章

## 避免使用子查询，可以把子查询优化为join操作

- 通常**子查询在 in 子句中**，且**子查询中为简单 SQL**(不包含 union、group by、order by、limit 从句) 时,**才可以把子查询转化为关联查询进行优化**。

  **子查询性能差的原因：** 子查询的结果集无法使用索引，通常**子查询的结果集会被存储到临时表**中，不论是**内存临时表还是磁盘临时表都不会存在索引**，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会**消耗过多的 CPU 和 IO 资源**，产生大量的慢查询。

## 避免JOIN关联太多的表

- 对于 MySQL 来说，是存在**关联缓存**的，**缓存的大小可以由 join_buffer_size** 参数进行设置。

- 在 MySQL 中，对于同一个 SQL **多关联（join）一个表**，就会**多分配一个关联缓存**，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。

- 如果程序中**大量的使用了多表关联**的操作，同时 **join_buffer_size 设置的也不合理**的情况下，就容易造成**服务器内存溢出**的情况，就会**影响到服务器数据库性能的稳定**性。

- 同时对于关联操作来说，会产生临时表操作，影响查询效率，**MySQL 最多允许关联 61 个表**，**建议不超过 5 个**。

## 减少同数据库的交互次数

数据库**更适合处理批量**操作，**合并多个相同的操作到一起**，可以提高处理效率。

## 对应同一列进行or判断时，使用in代替or

in 的值不要超过 500 个，**in 操作可以更有效的利用索引**，**or 大多数情况下很少能利用到索引**。

## 禁止使用order by rand() 进行随机排序

- order by rand() 会把表中**所有符合条件的数据装载到内存**中，然后**在内存中对所有数据根据随机生成的值进行排序**，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会**消耗大量的 CPU 和 IO 及内存资源**。

- 推荐**在程序中获取一个随机值**，然后**从数据库中获取数据**的方式。

## WHERE从句中禁止对列进行函数转换和计算

**对列进行函数转换或计算**时会导致无法使用索引

**不推荐：**

```sql
where date(create_time)='20190101'
```

**推荐：**

```sql
where create_time >= '20190101' and create_time < '20190102'
```

## 在明显不会有重复值时使用UNION ALL 而不是 UNION

- UNION 会把两个结果集的所有数据放到临时表中后**再进行去重**操作
- **UNION ALL 不会再对结果集进行去重**操作

## 拆分复杂的大SQL为多个小SQL

- **大 SQL 逻辑上比较复杂**，需要**占用大量 CPU 进行计算**的 SQL
- MySQL 中，一个 SQL 只能使用一个 CPU 进行计算
- **SQL 拆分后可以通过并行执行**来提高处理效率

## 程序连接不同的数据库使用不同的账号，禁止跨库查询

- 为数据库**迁移**和**分库分表**留出余地
- **降低业务耦合度**
- **避免权限过大而产生的安全风险**

# 数据库操作行为规范

##  超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作

1. **大批量操作可能会造成严重的主从延迟**

   主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况

2. **binlog 日志为 row 格式时会产生大量的日志**

   大批量写操作会产生大量日志，特别是对于 **row 格式二进制数据**而言，由于在 row 格式中会**记录每一行数据的修改**，我们一次修改的数据越多，产生的日志量也就会越多，**日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟**的一个原因

3. **避免产生大事务操作**

   大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。

   特别是**长时间的阻塞会占满所有数据库的可用连接**，这会使**生产环境中的其他应用无法连接到数据库**，因此一定要注意大批量写操作要进行**分批**

##  对于大表使用 pt-online-schema-change 修改表结构

- 避免**大表修改产生的主从延迟**
- 避免在**对表字段进行修改时进行锁表**

对**大表数据结构的修改**一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。

**pt-online-schema-change** 它会首先建立一个与原表结构相同的新表，并且**在新表上进行表结构的修改**，然后**再把原表中的数据复制到新表**中，并在**原表中增加一些触发器**。把原表中新增的数据也复制到新表中，在**行所有数据复制完成之后，把新表命名成原表**，并把原来的表删除掉。

> 把原来一个 DDL 操作，**分解成多个小的批次**进行。 

## 禁止为程序使用的账号赋予 super 权限

- 当**达到最大连接数**限制时，**还运行 1 个有 super 权限的用户**连接
- super 权限只能**留给 DBA 处理问题的账号**使用

## 对于程序连接数据库账号,遵循权限最小原则

- **程序使用数据库账号**只能在**一个 DB** 下使用，不准跨库
- **程序使用的账号**原则上**不准有 drop** 权限