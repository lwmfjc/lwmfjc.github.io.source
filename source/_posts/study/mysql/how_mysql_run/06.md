---
title: 06B+树索引
description: 06B+树索引
tags:
  - MySQL是怎样运行的
categories:
  - 学习
date: 2023-04-22 15:04:46
updated: 2023-04-22 15:04:46
---

> 学习《MySQL是怎样运行的》，感谢作者！

# 概述

数据页由**7个**组成部分，各个数据页可以组成一个**双向链表**，每个数据页中的记录会按照**主键值从小到大的顺序**组成一个**单向链表**。每个数据页都会为**它里面的记录**生成一个**页目录**，在通过主键查找某条记录的时候可以在**页目录**中使用二分法快速定位到**对应的槽**，然后再**遍历该槽**对应**分组中的记录**即可快速找到**指定**的记录。**页和记录**的关系    

> 页a，页b 可以**不在物理结构上相连**，只要通过**双向链表相关联**即可

![image-20230422205909858](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230422205909858.png)

# 没有索引时进行查找

假设我们要搜索**某个列**等于**某个常数**的情况：  
```SELECT [查询列表] FROM 表名 WHERE 列名 = xxx```

## 在一个页中查找

假设记录极少，所有记录可以**存放到一个页中**  

- 以**主键**位搜索条件：页目录中使用**二分法**快速定位到对应的**槽**，然后在**遍历槽对应分组中的记录**，即可快速找到指定记录
- 其他列作为搜索条件：对于**非主键**，数据页没有为**非主键列**建立所谓的**页目录**，所以**无法通过二分法**快速定位相应的槽。只能**从Infimum依次遍历**单向链表中的每条记录，然后对比，效率极低

## 在很多页中查找

两个步骤：  

- **定位到记录所在的页**
- 从**所在页内**查找相应的记录

**没有索引**情况下，不能快速定位到所在页，只能从**第一页**沿着**双向链表**一直往下找，而如果是主键，每一页则可以在**页目录**二分查找。  
不过由于要**遍历所有页**，所以超级**耗时**

# 索引

```shell
#例子
mysql> CREATE TABLE index_demo(
    -> c1 INT,
    -> c2 INT,
    -> c3 CHAR(1),
    -> PRIMARY KEY(c1)
    -> ) ROW_FORMAT=COMPACT;
```

> 完整的行格式

![image-20230423113811933](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423113811933.png)

简化的行格式  
![image-20230423111720338](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423111720338.png)

- record_type：**记录头信息**的一项属性，表示**记录的类型**。0：普通记录，2：Infimum记录，3：Supremum记录，1还没用过等会再说
- next_record：**记录头信息**的一项属性，表示从当前记录的**真实数据**到**下一条记录真实数据**的距离
- 各个列的值：这里只展示在index_demo表中的**3个列**，分别是c1、c2、c3
- 其他信息：包括**隐藏列**及**记录的额外信息**

改为竖着查看：  
![image-20230423114517255](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423114517255.png)

> 上面图6-4的箭头其实有一点点出入，应该是指向z真实数据第1列那个位置，如下 
> ![image-20230423114716300](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423114716300.png)

## 一个简单的索引方案

思考：在**根据某个条件**查找一些记录，为什么要**遍历所有**的**数据页**呢？因为各个**页**中的记录没有规律，不知道**搜索条件会匹配哪些页**  
思路：为**快速定位**记录所在的**数据页**而建立一个别的目录  

### 有序   

下一个数据页中**用户记录**的**主键值**必须大于上一页**用户记录**的**主键值**  
假设一页只能存放3条记录   

```shell
#插入3条记录
mysql> INSERT INTO index_demo VALUES(1,4,'u'),(3,9,'d'),(5,3,'y');
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0
```

此时页的情况  
**记录组成了单链表**  
![image-20230423120232629](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423120232629.png)

再**插入一条记录**  

```shell
mysql> INSERT INTO index_demo VALUES(4,4,'a');
Query OK, 1 row affected (0.01 sec)
```

(注意，页之间可能**不是连续**的)

![image-20230423120335929](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423120335929.png)

由于页10中**最大记录**是**5**，而页28中有一条记录是**4**，因为5>4，不符合**下一个数据页中用户记录的主键值**必须**大于上一页中用户记录的主键值**，所以在**插入主键值为4的记录时需要伴随着一次记录移动**，也就是把5的记录移动到**页28**中，再把**主键值4**的记录**插入到页10中**  
![image-20230423122233694](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423122233694.png)

这个过程表明，在对页中的记录进行**增删改**操作的过程中，我们必须通过一些诸如**记录移动**的操作来始终保证这个状态一直成立：**下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值**。这个过程也可以称为**页分裂**。

### 给所有的页建立一个目录项

前提：index_demo表中有多条记录的效果  
![image-20230423122443198](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423122443198.png)

1页有16KB，这些页在磁盘上可能并不连续，**要想从这么多页中**根据**主键值**快速定位**某些记录所在的页**，需要给他们编制一个**目录**，每个页对应一个**目录项**，每个目录项包括**两部分**：  

- 页的**用户记录**中**最小的主键值**，用**key**表示
- 页号，**page_no**表示 

![image-20230423122846720](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423122846720.png)

假设我们此时把**目录项**在**物理存储器上连续存储**，比如放到数组中，此时就可以**根据主键值**快速查找**某条记录**  

1. 先用二分法快速定位主键20的记录在**目录项3中**（因为**12<20<209**)，对应页是9

2. 根据前面说的方式在**页9中**定位具体记录    

   > 先在**页目录**中二分查找，找到对应的组后**沿链表遍历**

这个目录项的别名：**索引**

## InnoDB中的索引方案

### 上述方案的问题

- InnoDB使用页作为**管理存储空间**的基本单位，即**只能保证16KB**的**连续存储空间**，如果记录非常多，则需要的**连续存储空间**就**非常大**
- **增删改**是很频繁的，如果页28的记录全部移除，那么目录项2就没有出现的必要，即**要删除目录项2**，那么所有的**目录项**都需要**左移**/或者不移动，作为冗余**放到目录项列表**中，浪费空间

### 方案

复用之前存储用户记录的**数据页**来存储目录项，用了和**用户记录**进行区分，把这些**用来表示目录项**的记录称为**目录项记录**。如何区分一条记录是**普通用户记录**，还是**目录项记录**：使用**记录头信息**中的**record_type**属性  

- 0：普通用户记录
- 1：目录项记录
- 2：Infimum记录
- 3：Supremum记录

**将目录项放到数据页中**  
![image-20230423124952375](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230423124952375.png)

**新分配了一个编号为30的页来专门存储目录项记录**  
**目录项记录**和**普通的用户记录**的不同点  

- 目录项记录的**record_type**值为1，普通用户记录**record_type**值为0

- 目录项记录只有**主键值**和**页的编号**这两个列，而普通用户记录的**列**是用户自己定义的，可能包含许多列，另外还有**InnoDB**自己添加的**隐藏列**

- **记录头信息**中有一个名为**min_rec_flag**的属性，只有目录项记录的min_rec_flag属性才可能为1，普通记录的min_rec_flag属性都是0  

  > B+ 树中**每层**非叶子节点中的**最小的目录项**记录都会添加该标记

**其他**：  
它们用的是**一样的数据页**(**页面类型**都是Ox45BF ，这个属性在File Header 中)；页的**组成结构**也是一样的〈就是我们前面介绍过的**7 个部分**)；都会为主键值生成**Page Directory**（页目录）从而在**按照主键值进行查找**时可以**使用**
**二分法**来加快查询速度。

### 举例

