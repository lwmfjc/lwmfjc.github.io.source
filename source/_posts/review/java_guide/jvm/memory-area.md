---
title: memory-area
description: memory-area
categories:
  - 学习
tags:
  - 复习
  - 复习-javaGuide
  - 复习-javaGuide-并发
date: 2022-12-07 13:49:39
updated: 2022-12-07 13:49:39
---

> 转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!
>
> 如果没有特殊说明，针对的都是HotSpot虚拟机

# 前言

- 对于Java程序员，虚拟机自动管理机制，不需要像C/C++程序员为每一个new 操作去写对应的delete/free 操作，不容易出现**内存泄漏** 和 **内存溢出**问题
- 但由于内存控制权交给Java虚拟机，一旦出现内存泄漏和溢出方面问题，如果不了解虚拟机是怎么样使用内存，那么很难**排查任务**

# 运行时数据区域

**Java虚拟机**在执行Java程序的过程中，会把它管理的内存，**划分成若干个**不同的数据区域

JDK1.8之前：

1. 线程共享
   堆，方法区【永久代】(包括运行时常量池)
2. 线程私有
   虚拟机栈、本地方法栈、程序计数器
3. 本地内存(包括直接内存)

![Java 运行时数据区域（JDK1.8 之前）](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/java-runtime-data-areas-jdk1.7.png)

JDK1.8之后：  
![Java 运行时数据区域（JDK1.8 之后）](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/java-runtime-data-areas-jdk1.8.png)
1.8之后整个永久代改名叫"元空间"，且移到了本地内存中



规范（概括）：  
**线程私有**：程序计数器，虚拟机栈，本地方法栈

**线程共享**：堆，方法区，直接内存（非运行时数据区的一部分）

> Java虚拟机规范对于运行时数据区域的规定是相当宽松的，以堆为例：
>
> 1. 堆可以是连续，也可以不连续
> 2. 大小可以固定，也可以运行时按需扩展
> 3. 虚拟机实现者可以使用任何**垃圾回收算法管理堆**，设置不进行垃圾收集

## 程序计数器

- 是一块较小内存空间，看作是**当前线程所执行的字节码**的**行号指示器**

- 字节码解释器，工作时通过**改变这个计数器的值**来选取下一条需要执行的**字节码指令**

  > 分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器

- 而且，为了**线程切换后恢复到正确执行位置**，每条线程需要一个独立程序计数器，各线程计数器互不影响，独立存储，我们称这类内存区域为**"线程私有"**的内存

- 总结，**程序计数器**的作用

  - 字节码解释器通过**改变程序计数器来依次读取指令**，从而实现代码的流程控制
  - 多线程情况下，**程序计数器用于记录当前线程执行的位置**，从而当线程被切回来的时候能够知道该线程上次运行到哪

  > 程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随线程创建而创建，线程结束而死亡

## Java虚拟机栈

- Java虚拟机栈，**简称"栈"**，也是线程私有的，生命周期和线程相同，随线程创建而创建，线程死亡而死亡
- 除了**Native方法**调用的是**通过本地方法栈实现**的，其他所有的Java方法调用都是通过**栈**来实现的（需要和其他运行时数据区域比如**程序计数器**配合）
- **方法调用的数据**需要通过栈进行**传递**，**每一次方法调用**都会有一个对应的**栈帧被压入栈**，每一个**方法调用结束后**，都会有一个**栈帧被弹出**。
- 栈由一个个栈帧组成，

## 本地方法栈

## 堆

## 方法区

## 运行时常量池

## 直接内存

# HotSpot虚拟机对象探秘

## 对象的创建

## 对象的内存布局

## 对象的访问定位