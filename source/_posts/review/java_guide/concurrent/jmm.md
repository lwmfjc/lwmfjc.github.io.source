---
title: java内存模型
description: java内存模型
categories:
  - 学习
tags:
  - 复习
  - 复习-javaGuide
  - 复习-javaGuide-并发
date: 2022-11-21 10:57:24
updated: 2022-11-21 10:57:24
---

## 从CPU缓存模型说起

- redis是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题，**CPU缓存则是为了解决CPU处理速度和内存处理速度不对等的问题**

- 把内存看作外存的高速缓存，程序运行时把外存的数据复制到内存，由于**内存的处理速度远高于外存**，这样提高了处理速度

- 总结，**CPU Cache缓存的是内存数据**，用于解决**CPU处理速度和内存不匹配**的问题，内存缓存的是硬盘数据用于解决硬盘访问速度国漫的问题
  CPU Cache示意图：  

  ![image-20221121161418654](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221121161418654.png)
  CPU Cache通常分为三层，分别叫L1，L2，L3 Cache
  工作方式：  **先复制一份数据到CPUCache中，当CPU需要用的时候就可以从CPUCache中读取数据，运算完成后，将运算得到的数据，写回MainMemory中**，此时，会出现**内存缓存不一致的问题**，例子：执行了i++，如果两个线程同时执行，假设两个线程从CPUCach中读取的i=1，两个线程做了1++运算完之后再写回MainMemory，此时i=2 而正确结果为3

- CPU为了解决内存缓存不一致问题，可以通过制定**缓存一致协议（比如MESI协议）或其他手段**。指的是在 **CPU 高速缓存与主内存交互的时候需要遵守的原则和规范**
  ![image-20221121163447850](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221121163447850.png)
  操作系统，通过**内存模型MemoryModel**定义一系列规范来解决这个问题

## 指令重排序

- **什么是指令重排序？** 简单来说就是系统在**执行代码的时候并不一定是按照你写的代码的顺序**依次执行

- 指令重排有下面2种

  - 编译器优化重排：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。
  - 指令并行重排：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序
  - 内存系统也会有“重排序”，在JMM表现为主存和本地内存可能不一致

  即Java源代码会经历 **编译器优化重排**--->**指令并行重排**--->**内存系统重排**，最终编程操作系统可执行的**指令序列**

  极其重要★：指令重排序可以**保证串行语义一致**，但是**没有义务保证多线程间的语义也一致**，所以在多线程下指令重排可能导致一些问题

  > 编译器和处理器的指令重排序的处理方式不一样。对于**编译器**，通过**禁止特定类型的编译器重排序**的方式来禁止重排序。对于**处理器**，通过**插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）**的方式来禁止特定类型的处理器重排序。指令并行重排和内存系统重排都属于是处理器级别的指令重排序。
  >
  > 内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使**处理器写入、读取值之前**，**将主内存的值写入高速缓存，清空无效队列**，从而保障变量的可见性。

## JMM（JavaMemoryMode）

### 什么是 JMM？为什么需要 JMM？

> 一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。**Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。**

实际上，对于Java来说，可以**把JMM看作是Java定义的并发编程相关的一组规范**，除了抽象了线程和主内存之间的关系之外，还规定了**从Java源代码到CPU可执行指令的转化过程**要遵守哪些和并发相关的原则和规范，主要目的是为了**简化多线程编程**，**增强程序可移植性**。

> JMM 说白了就是定义了一些规范来解决这些问题，开发者可以利用这些规范更方便地开发多线程程序。对于 Java 开发者说，你不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 `volatile`、`synchronized`、各种 `Lock`）即可开发出并发安全的程序。

### JMM 是如何抽象线程和主内存之间的关系？

### Java 内存区域和 JMM 有何区别？

### happens-before 原则是什么？

### happens-before 常见规则有哪些？谈谈你的理解？

### happens-before 常见规则有哪些？谈谈你的理解？

## 再看并发编程三个重要特性

## 总结

