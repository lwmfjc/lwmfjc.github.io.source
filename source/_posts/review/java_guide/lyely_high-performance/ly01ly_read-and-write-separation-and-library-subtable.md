---
title: 数据库读写分离&分库分表详解
description: 数据库读写分离&分库分表详解
categories:
  - 学习
tags:
  - 复习
  - 复习-javaGuide
  - 复习-javaGuide-distributed_system
date: 2023-02-14 16:38:42
updated: 2023-02-14 16:38:42
---

> 转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!

## 读写分离

### 什么是读写分离？

见名思意，根据读写分离的名字，我们就可以知道：**读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。** 这样的话，就能够**小幅提升写**性能，**大幅提升读**性能。

我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。

 ![lyx-20241126133934044](attachments/img/lyx-20241126133934044.png)

一般情况下，我们都会选择**一主多从**，也就是一台**主数据库负责写**，其他的**从数据库负责读**。主库和从库之间会进行数据**同步**，以保证**从库**中数据的**准确性**。这样的架构实现起来比较**简单**，并且也**符合系统的写少读多**的特点。

### 读写分离会带来什么问题？如何解决？

读写分离对于提升数据库的并发非常有效，但是，同时也会引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 **主从同步延迟** 。

主从同步延迟问题的解决，没有特别好的一种方案（可能是我太菜了，欢迎评论区补充）。你可以根据自己的业务场景，参考一下下面几种解决办法。

**1.强制将读请求路由到主库处理。**

既然你从库的数据过期了，那我就**直接从主库读取**嘛！这种方案虽然会增加主库的压力，但是，实现起来比较简单，也是我了解到的使用最多的一种方式。

比如 **`Sharding-JDBC`** 就是采用的这种方案。通过使用 Sharding-JDBC 的 **`HintManager` 分片键值管理器**，我们可以**强制使用主库**。

```java
HintManager hintManager = HintManager.getInstance();
hintManager.setMasterRouteOnly();
// 继续JDBC操作
```

对于这种方案，你可以将那些必须获取最新数据的读请求都交给主库处理。

**2.延迟读取。**

还有一些朋友肯定会想既然主从同步存在延迟，那我就在**延迟之后读取**啊，比如主从同步延迟 0.5s,那我就 1s 之后再读取数据。这样多方便啊！方便是方便，但是也很扯淡。

不过，如果你是这样设计业务流程就会好很多：对于一些**对数据比较敏感**的场景，你可以在**完成写请求之后**，**避免立即**进行请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。

另外，[《MySQL 实战 45 讲》](https://time.geekbang.org/column/intro/100020801?code=ieY8HeRSlDsFbuRtggbBQGxdTh-1jMASqEIeqzHAKrI%3D)这个专栏中的[《读写分离有哪些坑？》](https://time.geekbang.org/column/article/77636)这篇文章还介绍了很多其他比较实际的解决办法，感兴趣的小伙伴可以自行研究一下。

### 如何实现读写分离？

不论是使用哪一种读写分离具体的实现方案，想要**实现读写分离**一般包含如下几步：

1. 部署多台数据库，选择**其中的一台作为主**数据库，**其他**的一台或者多台**作为从**数据库。
2. **保证**主数据库和从数据库之间的数据是**实时同步**的，这个过程也就是我们常说的**主从复制**。
3. 系统将**写请求交给主**数据库处理，读请求交给从数据库处理。[ 使用上 ]

落实到项目本身的话，常用的方式有两种：

**1.代理方式**

 ![lyx-20241126133934585](attachments/img/lyx-20241126133934585.png)

我们可以在**应用**和**数据**中间**加了一个代理层**。**应用**程序所有的**数据请求都交给代理层**处理，代理层负责**分离读写**请求，将它们**路由到对应的数据库**中。

提供类似功能的中间件有 **MySQL Router**（官方）、**Atlas**（基于 MySQL Proxy）、**Maxscale**、**MyCat**。

**2.组件方式**

在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。

这也是我**比较推荐**的一种方式。这种方式目前在各种互联网公司中**用的最多**的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 **`sharding-jdbc`** ，**直接引入 jar** 包即可使用，非常方便。同时，也**节省了很多运维的成本**。

你可以在 shardingsphere 官方找到 [sharding-jdbc 关于读写分离的操作](https://shardingsphere.apache.org/document/legacy/3.x/document/cn/manual/sharding-jdbc/usage/read-write-splitting/)。

### 主从复制原理是什么？

MySQL binlog(binary log 即二进制日志文件) 主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。

更具体和详细的过程是这个样子的（图片来自于：[《MySQL Master-Slave Replication on the Same Machine》](https://www.toptal.com/mysql/mysql-master-slave-replication-tutorial)）：

![lyx-20241126133935018](attachments/img/lyx-20241126133935018.png)

1. 主库将数据库中数据的变化写入到 binlog
2. 从库连接主库
3. 从库会创建一个 I/O 线程向主库请求更新的 binlog
4. 主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收
5. 从库的 I/O 线程将接收的 binlog 写入到 relay log 中。
6. 从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。

怎么样？看了我对主从复制这个过程的讲解，你应该搞明白了吧!

你一般看到 binlog 就要想到主从复制。当然，除了主从复制之外，binlog 还能帮助我们实现**数据恢复**。

🌈 拓展一下：

不知道大家有没有使用过阿里开源的一个叫做 canal 的工具。这个工具可以帮助我们实现 **MySQL** 和**其他数据源比如 Elasticsearch 或者另外一台 MySQL 数据库**之间的数据同步。很显然，这个工具的底层原理肯定也是依赖 **binlog**。canal 的原理就是模拟 MySQL 主从复制的过程，解析 binlog 将数据同步到其他的数据源。

另外，像咱们常用的分布式缓存组件 Redis 也是通过**主从复制实现的读写分离**。

🌕 简单总结一下：

**MySQL 主从复制是依赖于 binlog 。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。**

## 分库分表

读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：**如果 MySQL 一张表的数据量过大怎么办?**

换言之，**我们该如何解决 MySQL 的存储压力呢？**

答案之一就是 **分库分表**。

### 什么是分库？

**分库** 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。

**垂直分库** 就是把**单一数据库按照业务进行划分**，**不同的业务使用不同的数据库**，进而将一个数据库的压力分担到多个数据库。

举个例子：说你将数据库中的**用户表**、**订单表**和**商品表**分别单独拆分为**用户数据库**、**订单数据库**和**商品数据库**。

![lyx-20241126133935447](attachments/img/lyx-20241126133935447.png)

**水平分库** 是把**同一个表按一定规则拆分**到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，**解决了单表的存储**和**性能瓶颈**的问题。

举个例子：订单表数据量太大，你对订单表进行了水平切分（水平分表），然后将切分后的 2 张订单表分别放在两个不同的数据库。

![lyx-20241126133936004](attachments/img/lyx-20241126133936004.png)

### 什么是分表？

**分表** 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。

**垂直分表** 是对数据表列的拆分，把一张列比较多的表拆分为多张表。

举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。

**水平分表** 是对数据表行的拆分，把**一张行比较多的表拆分为多张表**，可以解决单一表数据量过大的问题。

举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。

水平拆分只能解决单表数据量大的问题，为了**提升性能**，我们通常会选择**将拆分后的多张表放在不同的数据库**中。也就是说，**水平分表通常和水平分库同时出现**。

 ![lyx-20241126133936425](attachments/img/lyx-20241126133936425.png)

### 什么情况下需要分库分表？

遇到下面几种场景可以考虑分库分表：

- **单表的数据**达到**千万**级别以上，数据库**读写速度比较缓慢**。
- 数据**库中的数据**占用的**空间**越来越大，**备份时间**越来越长。
- 应用的**并发量太大**。

### 常见的分片算法有哪些？

分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。

- **哈希分片** ：求指定 key（比如 id） 的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合**随机读写**的场景，**不太适合经常需要范围查询**的场景。
- **范围分片** ：按照**特性**的**范围区间**（比如**时间**区间、**ID**区间）来分配数据，比如 将 `id` 为 `1~299999` 的记录分到第一个库， `300000~599999` 的分到第二个库。范围分片适合需要**经常进行范围查找**的场景，**不太适合随机读写**的场景（数据未被分散，**容易出现热点数据**的问题）。
- **地理位置分片** ：很多 NewSQL 数据库都支持**地理位置分片**算法，也就是根据地理位置（如城市、地域）来分配数据。
- **融合算法** ：灵活组合多种分片算法，比如将**哈希分片**和**范围分片**组合。
- ......

### 分库分表会带来什么问题呢？

记住，你在公司做的任何技术决策，不光是要考虑这个技术能不能满足我们的要求，**是否适合当前业务**场景，还要重点考虑其带来的成本。

引入分库分表之后，会给系统带来什么挑战呢？

- **join 操作** ： 同一个数据库中的表分布在了不同的数据库中，导致**无法使用 join** 操作。这样就导致我们需要**手动进行数据的封装**，比如你在一个数据库中**查询到一个数据**之后，再根据这个数据**去另外一个数据库**中找对应的数据。
- **事务问题** ：**同一个数据库中的表分布在了不同的数据库**中，如果**单个操作涉及到多个数据库**，那么数据库**自带的事务**就无法满足我们的要求了。
- **分布式 id** ：分库之后， 数据遍布在不同服务器上的数据库，数据库的**自增主键已经没办法满足生成的主键唯一**了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统引入分布式 id 了。
- ......

另外，引入分库分表之后，一般需要 **DBA** 的参与，同时还需要更多的数据库服务器，这些都属于成本。

### 分库分表有没有什么比较推荐的方案？

ShardingSphere 项目（包括 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar）是当当捐入 Apache 的，目前主要由京东数科的一些巨佬维护。

 ![lyx-20241126133936845](attachments/img/lyx-20241126133936845.png)

**ShardingSphere** 绝对可以说是当前**分库分表的首选**！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供**分布式事务**、**数据库治理**等功能。

另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。

艿艿之前写了一篇分库分表的实战文章，各位朋友可以看看：[《芋道 Spring Boot 分库分表入门》](https://mp.weixin.qq.com/s/A2MYOFT7SP-7kGOon8qJaw) 。

### 分库分表后，数据怎么迁移呢？

分库分表之后，我们如何将老库（单库单表）的数据迁移到新库（分库分表后的数据库系统）呢？

比较简单同时也是非常常用的方案就是**停机迁移**，**写个脚本老库的数据写到新库中**。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计 1 小时。然后，你写一个脚本将老库的数据都同步到新库中。

如果你不想停机迁移数据的话，也可以考虑**双写方案**。双写方案是针对那种**不能停机**迁移的场景，实现起来要稍微麻烦一些。具体原理是这样的：

- 我们对**老库的更新**操作（增删改），同时也要**写入新库**（双写）。如果操作的数据**不存在于新库的话，需要插入**到新库中。 这样就能保证，咱们新库里的数据是最新的。
- 在迁移过程，双写只会让被更新操作过的老库中的数据同步到新库，我们还需要自己写脚本将**老库中的数据(这里说的就是原来老库中的数据但是没有设计更新操作)**和新库的数据做比对。如果**新库中没有，那咱们就把数据插入**到新库。如果**新库有，旧库没有，就把新库对应的数据删除**（冗余数据清理）。
- 重复上一步的操作，直到老库和新库的数据一致为止。

想要在项目中实施双写还是比较麻烦的，很容易会出现问题。我们可以借助上面提到的数据库同步工具 **Canal 做增量数据迁移**（还是依赖 binlog，开发和维护成本较低）。

## 总结

- 读写分离主要是为了将**对数据库的读写**操作**分散到不同的数据库节点**上。 这样的话，就能够小幅提升写性能，大幅提升读性能。
- 读写分离**基于主从复制**，MySQL 主从复制是**依赖于 binlog** 。
- **分库** 就是将数据库中的数据分散到不同的数据库上。**分表** 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。
- 引入分库分表之后，需要系统解决**事务**、**分布式 id**、**无法 join 操作**问题。
- **ShardingSphere** 绝对可以说是当前分库分表的首选！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。